<!DOCTYPE html>
<html>

<head>
  <!-- <meta charset="UTF-8">selectBookingAccount -->

  <script src="https://live.zwidgets.com/js-sdk/1.4/ZohoEmbededAppSDK.min.js"></script>

  <style>
    * {
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Inter", Arial, sans-serif;
      padding: 16px;
      background: #f8fafc;
      margin: 0 auto;
      color: #0f172a;
      line-height: 1.5;
      max-width: 1200px;
    }

    h3 {
      margin: 0 0 20px 0;
      font-size: 16px;
      font-weight: 600;
      color: #1e293b;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .step-number {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 24px;
      height: 24px;
      background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
      color: white;
      border-radius: 50%;
      font-size: 13px;
      font-weight: 700;
      flex-shrink: 0;
    }

    /* Keep labels normal everywhere */
    label {
      display: block;
      margin-bottom: 8px;
    }

    /* Billing options container */
    /* Billing options wrapper */
    #billingOptions {
      text-align: left !important;
    }


    .billing-option input[type="radio"]:checked+.option-text,
    .billing-option:has(input[type="radio"]:checked) {
      border-color: #2563eb;
      background: #f1f5ff;
    }


    /* Force single left-aligned row */
    .billing-row {
      display: flex !important;
      align-items: center !important;
      justify-content: flex-start !important;
      gap: 8px;

      width: 100%;
    }

    /* Radio */
    .billing-row input[type="radio"] {
      margin: 0 !important;
      flex-shrink: 0;
    }

    /* Text */
    .billing-text {
      text-align: left;
      line-height: 1.4;
    }


    /* Text */
    .billing-option span {
      display: inline-block;
      text-align: left;
    }


    label:first-child {
      margin-top: 0;
    }

    label span.required {
      color: #ef4444;
      margin-left: 2px;
    }

    input,
    select {
      width: 100%;
      padding: 10px 12px;
      margin-top: 4px;
      border: 1.5px solid #e2e8f0;
      border-radius: 8px;
      font-size: 14px;
      font-family: inherit;
      color: #0f172a;
      background: #ffffff;
      transition: all 0.2s ease;
    }

    input:focus,
    select:focus {
      outline: none;
      border-color: #2563eb;
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
    }

    input:hover,
    select:hover {
      border-color: #cbd5e1;
    }

    select {
      cursor: pointer;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23475569' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 12px center;
      padding-right: 36px;
    }

    .card {
      background: #ffffff;
      padding: 20px;
      border-radius: 10px;
      margin-bottom: 16px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
      border: 1px solid #e2e8f0;
      transition: box-shadow 0.2s ease, border-color 0.2s ease;
    }

    .card:hover {
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      border-color: #cbd5e1;
    }

    .subheading {
      font-size: 13px;
      font-weight: 600;
      color: #0f172a;
      margin-bottom: 8px;
    }

    .hidden {
      display: none !important;
    }

    .box {
      background: #ffffff;
      padding: 8px;
      margin-top: 8px;
      border-radius: 8px;
      border: 1px solid #e2e8f0;
      max-height: 200px;
      overflow-y: auto;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .box div {
      padding: 10px 12px;
      cursor: pointer;
      border-radius: 6px;
      transition: all 0.2s ease;
      font-size: 14px;
      color: #334155;
    }

    .box div:hover {
      background: #f1f5f9;
      color: #0f172a;
    }

    .box div:not(:last-child) {
      border-bottom: 1px solid #f1f5f9;
    }

    .manualBillingFields {
      margin-top: 10px;
    }

    .multi-select {
      border: 1.5px solid #e2e8f0;
      border-radius: 8px;
      padding: 10px 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      background: #fff;
      font-size: 14px;
      transition: all 0.2s ease;
      margin-top: 4px;
    }

    .multi-select:hover {
      border-color: #cbd5e1;
    }

    .multi-select.active {
      border-color: #2563eb;
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
    }

    .selected-values {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      flex: 1;
      min-height: 20px;
      align-items: center;
    }

    .selected-values.empty {
      color: #94a3b8;
    }

    .role-chip {
      background: linear-gradient(135deg, #eef2ff 0%, #e0e7ff 100%);
      color: #3730a3;
      padding: 4px 10px;
      border-radius: 16px;
      font-size: 12px;
      font-weight: 600;
      border: 1px solid #c7d2fe;
    }

    .dropdown-arrow {
      font-size: 14px;
      color: #64748b;
      transition: transform 0.2s ease;
      flex-shrink: 0;
    }

    .multi-select.active .dropdown-arrow {
      transform: rotate(180deg);
    }

    .multi-dropdown {
      border: 1.5px solid #e2e8f0;
      border-radius: 8px;
      background: #fff;
      margin-top: 8px;
      padding: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      max-height: 200px;
      overflow-y: auto;
    }

    .multi-dropdown label {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 14px;
      margin: 8px 0;
      cursor: pointer;
      padding: 8px;
      border-radius: 6px;
      transition: background 0.2s ease;
      font-weight: 500;
      color: #334155;
    }

    .multi-dropdown label:hover {
      background: #f8fafc;
    }

    .multi-dropdown input[type="checkbox"] {
      width: 18px;
      height: 18px;
      margin: 0;
      cursor: pointer;
      accent-color: #2563eb;
      flex-shrink: 0;
    }

    /* Billing radio group */
    .billing-options {
      display: flex;
      flex-direction: column;
      padding: 12px;
      background: #f8fafc;
      border: 1px solid #e2e8f0;
      border-radius: 10px;
    }

    .billing-option {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      background: #fff;
      transition: all 0.15s ease;
      cursor: pointer;
    }

    .billing-option:hover {
      border-color: #cbd5e1;
      box-shadow: 0 2px 6px rgba(15, 23, 42, 0.08);
    }

    .billing-option input[type="radio"] {
      accent-color: #2563eb;
      width: fit-content;
    }

    .billing-option .option-text {
      display: flex;
      flex-direction: column;
      gap: 3px;
      width: 100%;

    }

    .billing-option .option-title {
      font-weight: 600;
      color: #0f172a;
      font-size: 14px;
    }

    .billing-option .option-desc {
      color: #64748b;
      font-size: 13px;
      line-height: 1.4;
    }

    .checkbox-group {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-top: 16px;
      padding: 12px;
      background: #f8fafc;
      border-radius: 8px;
      border: 1px solid #e2e8f0;
      transition: all 0.2s ease;
      cursor: pointer;
    }

    .checkbox-group:hover {
      background: #f1f5f9;
      border-color: #cbd5e1;
    }

    .checkbox-group input[type="checkbox"] {
      width: 18px;
      height: 18px;
      margin: 0;
      cursor: pointer;
      accent-color: #2563eb;
      flex-shrink: 0;
    }

    .checkbox-group label {
      margin: 0;
      font-weight: 500;
      color: #334155;
      cursor: pointer;
      flex: 1;
    }

    .account-card {
      display: flex;
      gap: 12px;
      padding: 14px;
      border: 1.5px solid #e2e8f0;
      border-radius: 10px;
      margin-bottom: 12px;
      cursor: pointer;
      background: #ffffff;
      transition: all 0.2s ease;
    }

    .account-card:hover {
      border-color: #2563eb;
      background: #f8fafc;
    }

    .account-card.selected {
      border-color: #2563eb;
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.15);
      background: #f1f5ff;
    }

    .account-radio {
      padding-top: 4px;
      /* aligns radio with name */
    }

    .account-content {
      flex: 1;
    }

    .account-name {
      font-weight: 600;
      color: #0f172a;
      margin-bottom: 4px;
    }

    .account-address {
      font-size: 13px;
      color: #475569;
      line-height: 1.4;
    }


    button {
      margin-top: 20px;
      width: 100%;
      padding: 14px 20px;
      background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
      color: #fff;
      border: none;
      border-radius: 8px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 2px 4px rgba(37, 99, 235, 0.3);
      letter-spacing: 0.3px;
    }

    button:hover:not(:disabled) {
      background: linear-gradient(135deg, #1d4ed8 0%, #1e40af 100%);
      box-shadow: 0 4px 8px rgba(37, 99, 235, 0.4);
      transform: translateY(-1px);
    }

    button:active:not(:disabled) {
      transform: translateY(0);
      box-shadow: 0 2px 4px rgba(37, 99, 235, 0.3);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    /* Submit Button States */
    #submitButton.processing {
      background: linear-gradient(135deg, #64748b 0%, #475569 100%);
      box-shadow: 0 2px 4px rgba(100, 116, 139, 0.3);
    }

    #submitButton.success {
      background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
      box-shadow: 0 2px 4px rgba(34, 197, 94, 0.3);
    }

    #submitButton.error {
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
      box-shadow: 0 2px 4px rgba(239, 68, 68, 0.3);
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    #submitButton.processing {
      animation: pulse 1.5s ease-in-out infinite;
    }

    .submit-message-success {
      background: #dcfce7;
      color: #166534;
      border: 1px solid #86efac;
    }

    .submit-message-error {
      background: #fee2e2;
      color: #991b1b;
      border: 1px solid #fca5a5;
    }

      .billing-option input[type="radio"] {
        margin-top: 2px;
        accent-color: #2563eb;
    }

    .address-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
    }

    @media (max-width: 768px) {
      .address-grid {
        grid-template-columns: 1fr;
      }
    }


    .billing-dependent {
      margin-left: 28px;
      /* aligns under label text */
      margin-top: 10px;
    }

    .billing-dependent {
      margin-left: 28px;
      margin-top: 10px;
    }


    label {
      margin-top: 2px;
    }

    .billing-option.selected {
      border-color: #2563eb;
      background: #f1f5ff;
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.15);
    }



    /* Scrollbar styling */
    .box::-webkit-scrollbar,
    .multi-dropdown::-webkit-scrollbar {
      width: 6px;
    }

    .radio-div {
      width: 100%;
      border: 1px solid green;
      display: flex;
      flex-direction: column
    }

    .box::-webkit-scrollbar-track,
    .multi-dropdown::-webkit-scrollbar-track {
      background: #f1f5f9;
      border-radius: 3px;
    }

    .box::-webkit-scrollbar-thumb,
    .multi-dropdown::-webkit-scrollbar-thumb {
      background: #cbd5e1;
      border-radius: 3px;
    }

    .box::-webkit-scrollbar-thumb:hover,
    .multi-dropdown::-webkit-scrollbar-thumb:hover {
      background: #94a3b8;
    }
  </style>
</head>

<body>
  <!-- ================= CONTEXT: BELONGS TO ================= -->
  <!-- <div class="card" style="margin-bottom: 20px;">
    <h3>
      <span class="step-number">1</span>
      Who does this location belong to?
    </h3>

    <label>Belongs To <span class="required">*</span></label>
    <select id="belongsTo" onchange="onBelongsToChange()">
      <option value="">Select</option>
    </select>

    <label id="belongsSearchLabel" class="hidden"></label>
    <input id="belongsSearchInput" class="hidden" type="text" placeholder="Type at least 3 characters..."
      onkeyup="searchBelongsEntity()" />

    <div id="belongsSearchResults" class="box hidden"></div>

    <label id="attachedAccountLabel" class="hidden">
      Attached Account
    </label>
    <input id="attachedAccountInput" class="hidden" type="text" disabled />
  </div> -->

  <div class="card">
    <!-- <h3>
      <span class="step-number">2</span>
      Addresses
    </h3> -->


    <div style="display:grid;grid-template-columns:1fr;gap:16px;">

      <!-- SHIPPING ADDRESS SECTION -->
      <div>
        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
          <h3 style="margin: 0;">Shipping Address</h3>
          <button type="button" onclick="resetShippingAddress()" style="
            background: #f0f0f0;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 2px 8px;
            width: fit-content;
            cursor: pointer;
            font-size: 11px;
            color: #666;
          ">Reset</button>
        </div>

        <!-- Belongs To for Shipping -->
        <label>Belongs To <span class="required">*</span></label>
        <select id="shippingBelongsTo" onchange="onShippingBelongsToChange()">
          <option value="">Select</option>
          <option value="LANDLORD">Landlord / Owner</option>
          <option value="PARENT_COMPANY">Parent Company</option>
          <option value="PROPERTY_MANAGEMENT">Property Management Company</option>
          <option value="SUBCONTRACTOR">Subcontractor / Partner</option>
          <option value="DIRECT_CLIENT">Direct Client</option>
          <option value="HOUSEHOLD">Household</option>
          <option value="TENANT">Tenant</option>
          <option value="INDIVIDUAL_CLIENT">Individual Client / Site Contact</option>
          <option value="STAFF">Staff / Dispatcher</option>
        </select>

        <!-- Shipping Address Selection (searches from contacts) -->
        <div id="shippingAddressSelectSection" style="margin-top: 15px;">
          <label>Shipping Address</label>
          <select id="shippingAddressOption" onchange="onShippingAddressOptionChange()">
            <option value="">Select</option>
            <option value="CREATE_NEW">+ Create New Shipping Address</option>
            <option value="SEARCH_ADDRESS">üîç Search Address</option>
            <!-- Dynamic options: addresses from contacts with contact info and role in brackets -->
          </select>
          <p id="shippingAddressOptionHint" style="font-size: 12px; color: #64748b; margin: 4px 0 0 0;">
            Select an existing address or create new
          </p>
          
          <!-- Search Address Input Container -->
          <div id="addressSearchContainer" class="hidden" style="margin-top: 12px; padding: 12px; background: #f0f9ff; border: 1px solid #bae6fd; border-radius: 8px;">
            <label style="font-size: 13px; color: #0369a1; font-weight: 500;">Search by Street, City, or Postal Code</label>
            <div style="display: flex; align-items: center; gap: 10px; margin-top: 6px;  justify-content: space-between;">
              <input type="text" id="addressSearchInput" placeholder="Enter address to search..." 
                style="padding: 10px 12px; border: 1px solid #bae6fd; border-radius: 6px; font-size: 14px;"
                oninput="debounceAddressSearch()">
              <button type="button" onclick="performAddressSearch()" 
                style="padding: 10px 16px; background: #0284c7; margin:auto; color: white; width: fit-content; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">
                Search
              </button>
            </div>
            <p id="addressSearchHint" style="font-size: 11px; color: #64748b; margin: 6px 0 0 0;">
              Type at least 3 characters to search
            </p>
            
            <!-- Search Results -->
            <div id="addressSearchResults" class="hidden" style="margin-top: 10px; max-height: 200px; overflow-y: auto; border: 1px solid #e2e8f0; border-radius: 6px; background: white;">
              <!-- Results will be populated dynamically -->
            </div>
          </div>
          
          <!-- Billing Same as Shipping Checkbox -->
          <div style="margin-top: 12px; padding: 10px; background: #f0f9ff; border: 1px solid #bae6fd; border-radius: 6px;">
            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 14px; color: #0369a1;">
              <input type="checkbox" id="billingSameAsShipping" onchange="onBillingSameAsShippingChange()" style="width: 16px; height: 16px; cursor: pointer;">
              <span>Billing address same as shipping address</span>
            </label>
          </div>
          </div>

        <!-- Contact Details Fields for Shipping -->
          <div id="shippingContactFields" style="margin-top: 15px; padding: 15px; background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px;">
            <div class="subheading" style="margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center;">
              <span id="shippingContactFieldsTitle">Contact Details</span>
            <span id="shippingContactFieldsStatus" style="font-size: 11px; padding: 2px 8px; border-radius: 4px; background: #fef3c7; color: #92400e;">From Lead</span>
            </div>

            <label>Name <span class="required">*</span></label>
            <input id="shippingContactName" type="text" placeholder="Enter contact name" oninput="syncBillingWithShipping()">

            <label>Email <span class="required">*</span></label>
            <input id="shippingContactEmail" type="email" placeholder="Enter email address" oninput="syncBillingWithShipping()">

            <label>Phone <span class="required">*</span></label>
            <input id="shippingContactPhone" type="tel" placeholder="(xxx) xxx-xxxx" oninput="formatPhoneInput(this); syncBillingWithShipping()">

            <p id="shippingContactUpdateWarning" class="hidden" style="margin: 8px 0 12px 0; font-size: 12px; color: #dc2626; font-style: italic;">
              Note: Changes will update this contact across all linked records.
            </p>

            <label>Contact Role(s) <span class="required">*</span></label>
            <div class="multi-select" onclick="toggleRoleDropdown()">
              <div id="selectedRoles" class="selected-values empty">
                Select role(s)
              </div>
              <div class="dropdown-arrow">‚ñæ</div>
            </div>

            <div id="roleDropdown" class="multi-dropdown hidden">
              <label><input type="checkbox" value="BILLING" onchange="updateRoles()"> Billing</label>
              <label><input type="checkbox" value="BOOKING" onchange="updateRoles()"> Booking</label>
              <label><input type="checkbox" value="ADMIN" onchange="updateRoles()"> Admin</label>
              <label><input type="checkbox" value="TENANT" onchange="updateRoles()"> Tenant</label>
            </div>

            <div class="checkbox-group hidden">
              <input type="checkbox" id="doNotInvoice">
              <label for="doNotInvoice">Do Not Invoice</label>
          </div>
        </div>

        <!-- Shipping Address Fields - ALWAYS VISIBLE -->
        <div id="shippingAddressFields" style="margin-top: 15px; padding: 15px; background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px;">
          <div class="subheading" style="margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center;">
            <span>Shipping Address</span>
            <span id="shippingAddressStatus" style="font-size: 11px; padding: 2px 8px; border-radius: 4px; background: #dcfce7; color: #166534;">Editable</span>
          </div>

          <label>Room Location</label>
          <input id="shipRoomLocation" placeholder="e.g., Suite 101, Room 5B, Unit A" oninput="syncBillingWithShipping()">

          <label>Street</label>
          <input id="shipStreet" oninput="syncBillingWithShipping()">

          <label>City</label>
          <input id="shipCity" oninput="syncBillingWithShipping()">

          <label>Province</label>
          <input id="shipProvince" oninput="syncBillingWithShipping()">

          <label>Postal Code</label>
          <input id="shipPostal" placeholder="A1A 1A1" oninput="handlePostalCodeInput(this, 'shipPostalError'); syncBillingWithShipping()">
          <p id="shipPostalError" style="display: none; margin: 4px 0 0 0; font-size: 12px; color: #dc2626;">
            Invalid Canadian postal code format. Use: A1A 1A1
          </p>

          <label>Country</label>
          <input id="shipCountry" oninput="syncBillingWithShipping()">

          <p id="shippingAddressUpdateWarning" class="hidden" style="margin: 12px 0 0 0; font-size: 12px; color: #dc2626; font-style: italic;">
            Note: Changes will update this address across all linked records.
          </p>
        </div>
      </div>

      <!-- BILLING -->
      <div id="billingAddressSection">
        <div style="display: flex; align-items: center; justify-content: space-between; gap: 10px; margin-bottom: 8px;">
          <h3 style="margin: 0;">Billing Address</h3>
          <button type="button" onclick="resetBillingAddress()" style="
            background: #f0f0f0;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 2px 8px;
            width: fit-content;
            cursor: pointer;
            font-size: 11px;
            color: #666;
          ">Reset</button>
        </div>
        <label>Belongs To <span class="required">*</span></label>
        <select id="belongsTo" onchange="onBelongsToChange()">
          <option value="">Select</option>
        </select>

        <label id="belongsSearchLabel" class="hidden"></label>
        <input id="belongsSearchInput" class="hidden" type="text" placeholder="Type at least 3 characters..."
          onkeyup="searchBelongsEntity()" />


        <div id="belongsSearchResults" class="box hidden"></div>

        <label id="attachedAccountLabel" class="hidden">
          Attached Account
        </label>
        <input id="attachedAccountInput" class="hidden" type="text" disabled />

        <!-- HIDDEN: Old billing options - replaced by new billingAddressOption dropdown -->
        <div id="billingOptions" class="billing-options hidden" style="display: none !important;">
          <div class="subheading" style="margin-top: 0;">Billing Address Options</div>

          <label class="billing-option">
            <input type="radio" name="billingOption" value="SAME" onchange="selectBillingOption(this.value)">
            <div class="option-text">
              <span class="option-title" id="lblOptionSame">Use an existing account associated with the shipping address.</span>
              <!-- <span class="option-desc">Pulls billing from the selected booking account.</span> -->
            </div>
          </label>

          <label class="billing-option">
            <input type="radio" name="billingOption" value="DIFFERENT" onchange="selectBillingOption(this.value)">
            <div class="option-text">
              <span class="option-title" id="lblOptionDifferent">Create a new account to associate with shipping address.</span>
              <!-- <span class="option-desc">Enter a custom billing address manually.</span> -->
            </div>
          </label>

          <label class="billing-option">
            <input type="radio" name="billingOption" value="SEARCH" onchange="selectBillingOption(this.value)">
            <div class="option-text">
              <span class="option-title" id="lblOptionSearch">Search for a different account</span>
              <!-- <span class="option-desc">Find another account and use its billing address.</span> -->
            </div>
          </label>

          <div id="billingSearchBox" class="billing-dependent hidden">
            <label>Search Account</label>
            <input type="text" placeholder="Search by name, email, phone or address..." onkeyup="searchBillingAccount(this.value)">
            <div id="billingSearchResults" class="box"></div>
          </div>
        </div>

        <div style="font-family: Arial;">
          <!-- <h3>Parent Accounts</h3> -->
          <label class="margin-top:10px">Parent Accounts</label>
          <!-- <button id="searchBtn">üîç Search Accounts</button> -->

          <div id="results" style="margin-top:15px;"></div>
        </div>

        <!-- select cases when user select exisitng account -->
        <!-- <div id="billingAccountUsageBox" class="card hidden">
          <h3>How do you want to use this billing account?</h3>

          <label>
            <input type="radio" name="billingAccountUsage" value="USE_EXISTING"
              onchange="selectBillingAccountUsage(this.value)">
            Use this account as-is
          </label>

          <label>
            <input type="radio" name="billingAccountUsage" value="SAME_ACCOUNT_DIFFERENT_ADDRESS"
              onchange="selectBillingAccountUsage(this.value)">
            Use same account, but different billing address
          </label>

          <label>
            <input type="radio" name="billingAccountUsage" value="NEW_ACCOUNT"
              onchange="selectBillingAccountUsage(this.value)">
            Create a new account using this billing address
          </label>
        </div> -->

        <div id="billingAccountUsageBox" class="card hidden">
          <div class="subheading">How do you want to use this billing account?</div>

          <label class="billing-option">
            <input type="radio" name="billingAccountUsage" value="USE_EXISTING"
              onchange="selectBillingAccountUsage(this.value)">
            <div class="option-text">
              <span class="option-title">Use this account as-is</span>
            </div>
          </label>

          <label class="billing-option">
            <input type="radio" name="billingAccountUsage" value="SAME_ACCOUNT_DIFFERENT_ADDRESS"
              onchange="selectBillingAccountUsage(this.value)">
            <div class="option-text">
              <span class="option-title">
                Use same account, but different billing address
              </span>
            </div>
          </label>

          <label class="billing-option">
            <input type="radio" name="billingAccountUsage" value="NEW_ACCOUNT"
              onchange="selectBillingAccountUsage(this.value)">
            <div class="option-text">
              <span class="option-title">
                Create a new account using this billing address
              </span>
            </div>
          </label>
        </div>


        <div id="newLandlordDetails" class="hidden" style="margin-top: 10px; padding-top: 10px; border-top: 1px dashed #e2e8f0;">
             <div class="subheading">New Landlord Details</div>
             <label>Landlord Name <span class="required">*</span></label>
             <input id="newLandlordName" type="text" placeholder="Enter landlord name">

             <label>Landlord Phone</label>
             <input id="newLandlordPhone" type="tel" placeholder="Enter phone number">

             <label>Landlord Email</label>
             <input id="newLandlordEmail" type="email" placeholder="Enter email address">
        </div>

        <!-- Billing Address Selection -->
        <div id="billingAddressSelectSection" style="margin-top: 15px;">
          <label>Billing Address</label>
          <select id="billingAddressOption" onchange="onBillingAddressOptionChange()">
            <option value="">Select</option>
            <option value="CREATE_NEW">+ Create New Billing Address</option>
            <option value="SAME_AS_SHIPPING">Same as Shipping Address</option>
            <option value="SEARCH_ADDRESS">üîç Search Address</option>
            <!-- Dynamic options populated here -->
          </select>
          <p id="billingAddressOptionHint" style="font-size: 12px; color: #64748b; margin: 4px 0 0 0;">
            Select billing address or create new
          </p>
          
          <!-- Search Billing Address Container -->
          <div id="billingAddressSearchContainer" class="hidden" style="margin-top: 12px; padding: 12px; background: #f0f9ff; border: 1px solid #bae6fd; border-radius: 8px;">
            <label style="font-size: 13px; color: #0369a1; font-weight: 500;">Search by Street, City, or Postal Code</label>
            <div style="display: flex; align-items: center; gap: 10px; margin-top: 6px; justify-content: space-between;">
              <input type="text" id="billingAddressSearchInput" placeholder="Enter address to search..." 
                style="padding: 10px 12px; border: 1px solid #bae6fd; border-radius: 6px; font-size: 14px;"
                oninput="debounceBillingAddressSearch()">
              <button type="button" onclick="performBillingAddressSearch()" 
                style="padding: 10px 16px; background: #0284c7; margin:auto; color: white; width: fit-content; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">
                Search
              </button>
            </div>
            <p id="billingAddressSearchHint" style="font-size: 11px; color: #64748b; margin: 6px 0 0 0;">
              Type at least 3 characters to search
            </p>
            
            <!-- Search Results -->
            <div id="billingAddressSearchResults" class="hidden" style="margin-top: 10px; max-height: 200px; overflow-y: auto; border: 1px solid #e2e8f0; border-radius: 6px; background: white;">
              <!-- Results will be populated dynamically -->
            </div>
          </div>
        </div>

        <!-- Account Details Fields - Always visible -->
        <div id="accountDetailsFields" style="margin-top: 15px; padding: 15px; background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px;">
          <div class="subheading" style="display: flex; align-items: center; justify-content: space-between;">
            <span>Account Details</span>
            <span id="accountDetailsStatus" style="font-size: 11px; padding: 2px 8px; border-radius: 4px; background: #e2e8f0; color: #64748b;">Select an option</span>
          </div>

          <label>Account Name <span class="required">*</span></label>
          <input id="accountName" type="text" placeholder="Enter account name">

          <label>Account Phone</label>
          <input id="accountPhone" type="tel" placeholder="(xxx) xxx-xxxx" oninput="formatPhoneInput(this)">

          <label>Account Email</label>
          <input id="accountEmail" type="email" placeholder="Enter email address">

          <p id="accountUpdateWarning" style="margin: 12px 0 0 0; font-size: 12px; color: #dc2626; font-style: italic;">
            Note: Changes will update this account's details across all linked records.
          </p>
        </div>

        <div id="manualBillingFields" style="margin-top: 15px; padding: 15px; background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px;">
          <div class="subheading" style="display: flex; align-items: center; justify-content: space-between;">
            <span>Billing Address Details</span>
            <span id="billingAddressStatus" style="font-size: 11px; padding: 2px 8px; border-radius: 4px; background: #dcfce7; color: #166534;">Editable</span>
          </div>

          <label>Billing Street</label>
          <input id="billStreet">

          <label>Billing City</label>
          <input id="billCity">

          <label>Billing Province</label>
          <input id="billProvince">

          <label>Billing Postal Code</label>
          <input id="billPostal" placeholder="A1A 1A1" oninput="handlePostalCodeInput(this, 'billPostalError')">
          <p id="billPostalError" style="display: none; margin: 4px 0 0 0; font-size: 12px; color: #dc2626;">
            Invalid Canadian postal code format. Use: A1A 1A1
          </p>

          <label>Billing Country</label>
          <input id="billCountry">

          <p id="billingAddressWarning" style="margin: 12px 0 0 0; font-size: 12px; color: #dc2626; font-style: italic;">
            Note: Changes will update this account's billing address across all linked records.
          </p>
        </div>

        <!-- Contact Details Section for Billing -->
        <div id="billingContactSection" class="hidden" style="margin-top: 15px; padding: 15px; background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px;">
          <div class="subheading" style="display: flex; align-items: center; justify-content: space-between;">
            <span>Contact Details</span>
            <span id="billingContactStatus" style="font-size: 11px; padding: 2px 8px; border-radius: 4px; background: #dcfce7; color: #166534;">Editable</span>
      </div>

          <label>Contact <span class="required">*</span></label>
          <select id="contactSelect" onchange="onContactSelectChange()">
            <option value="NEW">+ Create New Contact</option>
          </select>
          <p id="contactSelectHint" style="font-size: 12px; color: #64748b; margin: 4px 0 12px 0;">
            Select an existing contact or create a new one
          </p>

        <label>Name <span class="required">*</span></label>
        <input id="contactName" type="text" placeholder="Enter contact name">

          <label>Email</label>
        <input id="contactEmail" type="email" placeholder="Enter email address">

          <label>Phone</label>
        <input id="contactPhone" type="tel" placeholder="(xxx) xxx-xxxx" oninput="formatPhoneInput(this)">

          <p id="contactUpdateWarning" class="hidden" style="margin: 12px 0 0 0; font-size: 12px; color: #dc2626; font-style: italic;">
            Note: Changes will update this contact across all linked records.
          </p>
        </div>

        </div>

    </div>
  </div>

  <!-- ================= STEP 2 ================= -->

  <!-- <div class="card"> -->
  <!-- 
    <label>Account Type <span class="required">*</span></label>
    <select id="accountType" onchange="resetAccountSearch()">
      <option value="">Select account type</option>
      <option value="DIRECT">Direct Client</option>
      <option value="HOUSEHOLD">Household</option>
      <option value="LANDLORD">Landlord</option>
      <option value="PARENT">Parent Company</option>
      <option value="PMC">Property Management</option>
      <option value="SUB">Subcontractor</option>
    </select> -->
  <!-- 
    <label>Search Existing Account</label>
    <input id="accountSearch" type="text" placeholder="Type at least 3 characters to search..."
      onkeyup="searchAccount()">

    <div id="accountResults" class="box hidden"></div> -->

  <!-- <label>Use Existing or Create New <span class="required">*</span></label>
    <select id="accountDecision" onchange="handleAccountDecision()">
      <option value="">Select an option</option>
      <option value="USE">Use Existing</option>
      <option value="NEW">Create New</option>
    </select> -->

  <!-- <label id="newAccountNameLabel" style="display: none;">New Account Name <span class="required">*</span></label>
    <input id="newAccountName" type="text" placeholder="Enter new account name" style="display: none;"> -->
  <!-- </div> -->

  <!-- <div class="card">

    <div id="contactResults" class="box hidden"></div>

    <label>Contact Name <span class="required">*</span></label>
    <input id="contactName" type="text" placeholder="Enter contact name">

    <label>Email <span class="required">*</span></label>
    <input id="contactEmail" type="email" placeholder="Enter email address">

    <label>Phone <span class="required">*</span></label>
    <input id="contactPhone" type="tel" placeholder="(xxx) xxx-xxxx" oninput="formatPhoneInput(this)">
    <label>Contact Role(s) <span class="required">*</span></label>

    <div class="multi-select" onclick="toggleRoleDropdown()">
      <div id="selectedRoles" class="selected-values empty">
        Select role(s)
      </div>
      <div class="dropdown-arrow">‚ñæ</div>
    </div>

    <div id="roleDropdown" class="multi-dropdown hidden">
      <label><input type="checkbox" value="BILLING" onchange="updateRoles()"> Billing</label>
      <label><input type="checkbox" value="BOOKING" onchange="updateRoles()"> Booking</label>
      <label><input type="checkbox" value="ADMIN" onchange="updateRoles()"> Admin</label>
      <label><input type="checkbox" value="TENANT" onchange="updateRoles()"> Tenant</label>
    </div>

    <div class="checkbox-group">
      <input type="checkbox" id="doNotInvoice">
      <label for="doNotInvoice">Do Not Invoice</label>
    </div>
  </div> -->

  <!-- ================= STEP 4 - HIDDEN ================= -->
  <!-- Hidden: Billing centralized section - default set to NO -->
  <div class="card" style="display: none;">
    <select id="centralBilling">
      <option value="">Select</option>
      <option value="YES">Yes</option>
      <option value="NO" selected>No</option>
    </select>
    <input type="checkbox" id="isBillingAccount">
  </div>


  <div id="submitContainer" style="position: relative;">
    <button id="submitButton" onclick="submitWidget()">Confirm & Convert</button>
    <div id="submitMessage" style="display: none; margin-top: 10px; padding: 12px 16px; border-radius: 8px; font-size: 14px; text-align: center;"></div>
  </div>

  <script>
    let selectedAccount = null;
    let selectedContact = null;
    let currentLeadId = null;
    let selectedContactRoles = [];
    let shouldAutoSearchAccounts = false;
    let isAutoBillingSelection = false;
    
    // Mapping: Belongs To value -> Account Type
    // Contact Type will be the SAME as Belongs To value (not converted)
    const BELONGS_TO_ACCOUNT_TYPE_MAP = {
      "LANDLORD": "Landlord",
      "PARENT_COMPANY": "Parent Company",
      "PROPERTY_MANAGEMENT": "Property Management",
      "SUBCONTRACTOR": "Subcontractor",
      "DIRECT_CLIENT": "Direct Client",
      "HOUSEHOLD": "Household",
      "INDIVIDUAL_CLIENT": "Individual Client",
      "TENANT": "Tenant",
      "STAFF": "Staff"
    };
    
    // Define which "Belongs To" values are parent/account positions
    // These can use "Billing same as Shipping" option
    const PARENT_POSITION_BELONGS_TO = [
      "LANDLORD",
      "PARENT_COMPANY",
      "PROPERTY_MANAGEMENT",
      "SUBCONTRACTOR",
      "DIRECT_CLIENT",
      "HOUSEHOLD"
    ];
    
    // Helper function to check if belongs to is a parent position
    function isParentPosition(belongsToValue) {
      return PARENT_POSITION_BELONGS_TO.includes(belongsToValue);
    }
    
    // Helper function to get contact roles - uses SAME value as belongs to
    // Contact Type = Belongs To value directly
    function getRolesForBelongsTo(belongsToValue, isParentPosition) {
      // Always return the belongs to value as the contact role
      // This ensures Contact Type matches the selected Belongs To
      if (!belongsToValue) return [];
      return [belongsToValue];
    }
    
    // Helper function to get account type based on belongs to
    function getAccountTypeForBelongsTo(belongsToValue) {
      return BELONGS_TO_ACCOUNT_TYPE_MAP[belongsToValue] || belongsToValue;
    }
    
    // ========== PHONE NUMBER FORMATTING ==========
    // Format phone number for display: 1234567890 ‚Üí (123) 456-7890
    function formatPhoneDisplay(phone) {
      if (!phone) return "";
      // Strip all non-digits
      const digits = phone.toString().replace(/\D/g, "");
      // Format if we have 10 digits
      if (digits.length === 10) {
        return `(${digits.slice(0,3)}) ${digits.slice(3,6)}-${digits.slice(6)}`;
      }
      // If 11 digits starting with 1, format without country code
      if (digits.length === 11 && digits[0] === "1") {
        return `(${digits.slice(1,4)}) ${digits.slice(4,7)}-${digits.slice(7)}`;
      }
      // Return original if not standard format
      return phone;
    }

    // Strip formatting to get raw digits: (123) 456-7890 ‚Üí 1234567890
    function stripPhoneFormatting(phone) {
      if (!phone) return "";
      return phone.toString().replace(/\D/g, "");
    }

    // Format phone input as user types
    function formatPhoneInput(inputElement) {
      const cursorPos = inputElement.selectionStart;
      const oldValue = inputElement.value;
      const digits = oldValue.replace(/\D/g, "");
      
      // Format the value
      let formatted = "";
      if (digits.length <= 3) {
        formatted = digits.length > 0 ? `(${digits}` : "";
      } else if (digits.length <= 6) {
        formatted = `(${digits.slice(0,3)}) ${digits.slice(3)}`;
      } else {
        formatted = `(${digits.slice(0,3)}) ${digits.slice(3,6)}-${digits.slice(6,10)}`;
      }
      
      inputElement.value = formatted;
      
      // Adjust cursor position
      const newCursorPos = formatted.length;
      inputElement.setSelectionRange(newCursorPos, newCursorPos);
    }
    // ========== END PHONE NUMBER FORMATTING ==========
    
    // ========== CANADIAN POSTAL CODE VALIDATION ==========
    // Canadian postal code format: A1A 1A1 (letter-digit-letter space digit-letter-digit)
    const CANADIAN_POSTAL_REGEX = /^[A-Za-z]\d[A-Za-z][ ]?\d[A-Za-z]\d$/;
    
    // Validate Canadian postal code format
    function isValidCanadianPostal(postal) {
      if (!postal) return true; // Empty is handled by required validation
      return CANADIAN_POSTAL_REGEX.test(postal.trim());
    }
    
    // Format Canadian postal code: uppercase and add space (A1A1A1 ‚Üí A1A 1A1)
    function formatCanadianPostal(postal) {
      if (!postal) return "";
      // Remove all spaces and convert to uppercase
      let cleaned = postal.replace(/\s/g, "").toUpperCase();
      // Add space after 3rd character if we have 6+ characters
      if (cleaned.length >= 6) {
        cleaned = cleaned.slice(0, 3) + " " + cleaned.slice(3, 6);
      }
      return cleaned;
    }
    
    // Handle postal code input - format and validate
    function handlePostalCodeInput(inputElement, errorElementId) {
      const value = inputElement.value;
      const errorEl = document.getElementById(errorElementId);
      
      // Format the value (uppercase, add space)
      const formatted = formatCanadianPostal(value);
      
      // Only update if different to avoid cursor jumping
      if (inputElement.value !== formatted) {
        const cursorPos = inputElement.selectionStart;
        inputElement.value = formatted;
        // Adjust cursor position for added space
        const newPos = cursorPos + (formatted.length - value.length);
        inputElement.setSelectionRange(newPos > 0 ? newPos : formatted.length, newPos > 0 ? newPos : formatted.length);
      }
      
      // Validate and show/hide error
      if (errorEl) {
        if (formatted && !isValidCanadianPostal(formatted)) {
          errorEl.style.display = "block";
          inputElement.style.borderColor = "#dc2626";
        } else {
          errorEl.style.display = "none";
          inputElement.style.borderColor = "";
        }
      }
    }
    // ========== END CANADIAN POSTAL CODE VALIDATION ==========
    
    let initialLeadDetails = { 
      name: "", 
      email: "", 
      phone: "",
      // Shipping address
      shipRoomLocation: "",
      shipStreet: "",
      shipCity: "",
      shipProvince: "",
      shipPostal: "",
      shipCountry: "",
      // Billing address
      billStreet: "",
      billCity: "",
      billProvince: "",
      billPostal: "",
      billCountry: ""
    };


    // Get DOM elements
    const accountType = document.getElementById("accountType");
    const accountSearch = document.getElementById("accountSearch");
    const accountResults = document.getElementById("accountResults");
    const accountDecision = document.getElementById("accountDecision");
    const newAccountName = document.getElementById("newAccountName");
    const newAccountNameLabel = document.getElementById("newAccountNameLabel");
    const contactSearch = document.getElementById("contactSearch");
    const contactResults = document.getElementById("contactResults");
    const contactName = document.getElementById("contactName");
    const contactEmail = document.getElementById("contactEmail");
    const contactPhone = document.getElementById("contactPhone");
    const selectedRoles = document.getElementById("selectedRoles");
    const roleDropdown = document.getElementById("roleDropdown");
    const doNotInvoice = document.getElementById("doNotInvoice");
    const centralBilling = document.getElementById("centralBilling");
    const isBillingAccount = document.getElementById("isBillingAccount");
    const addressType = document.getElementById("addressType");
    const street = document.getElementById("street");
    const city = document.getElementById("city");
    const province = document.getElementById("province");
    const postal = document.getElementById("postal");
    const shipCountry = document.getElementById("shipCountry");
    const billCountry = document.getElementById("billCountry");

    const submitButton = document.getElementById("submitButton");
    const shipRoomLocation = document.getElementById("shipRoomLocation");
    const shipStreet = document.getElementById("shipStreet");
    const shipCity = document.getElementById("shipCity");
    const shipProvince = document.getElementById("shipProvince");
    const shipPostal = document.getElementById("shipPostal");

    const billStreet = document.getElementById("billStreet");
    const billCity = document.getElementById("billCity");
    const billProvince = document.getElementById("billProvince");
    const billPostal = document.getElementById("billPostal");

    const sameAsShipping = document.getElementById("sameAsShipping");

    let selectedBookingAccount = null;
    let selectedBillingOption = null;
    let selectedBillingAccount = null;

    let billingAccountUsage = {
      mode: null,            // USE_EXISTING | SAME_ACCOUNT_DIFFERENT_ADDRESS | NEW_ACCOUNT_FROM_ADDRESS
      sourceAccountId: null
    };

    // billingAccountUsage = {
    //   mode: "USE_EXISTING"
    //     | "SAME_ACCOUNT_DIFFERENT_ADDRESS"
    //     | "NEW_ACCOUNT_FROM_ADDRESS",

    //   sourceAccountId: selectedBillingAccount || null
    // };

    const BELONGS_TO_OPTIONS = [
      // ===== ACCOUNT BASED =====
      {
        value: "LANDLORD",
        label: "Landlord / Owner",
        source: "ACCOUNT"
      },
      {
        value: "PARENT_COMPANY",
        label: "Parent Company",
        source: "ACCOUNT"
      },
      {
        value: "PROPERTY_MANAGEMENT",
        label: "Property Management Company",
        source: "ACCOUNT"
      },
      {
        value: "SUBCONTRACTOR",
        label: "Subcontractor / Partner",
        source: "ACCOUNT"
      },
      {
        value: "DIRECT_CLIENT",
        label: "Direct Client",
        source: "ACCOUNT"
      },
      {
        value: "HOUSEHOLD",
        label: "Household",
        source: "ACCOUNT"
      },

      // ===== CONTACT BASED =====
      {
        value: "TENANT",
        label: "Tenant",
        source: "CONTACT"
      },
      {
        value: "INDIVIDUAL_CLIENT",
        label: "Individual Client / Site Contact",
        source: "CONTACT"
      },
      {
        value: "STAFF",
        label: "Staff / Dispatcher",
        source: "CONTACT"
      }
    ];

    const BILLING_USAGE_RULES = {
      LANDLORD: [
        "USE_EXISTING",
        "SAME_ACCOUNT_DIFFERENT_ADDRESS",
        "NEW_ACCOUNT"
      ],
      PROPERTY_MANAGEMENT: [
        "USE_EXISTING",
        "SAME_ACCOUNT_DIFFERENT_ADDRESS",
        "NEW_ACCOUNT"
      ],
      DIRECT_CLIENT: [
        "USE_EXISTING",
        "SAME_ACCOUNT_DIFFERENT_ADDRESS",
        "NEW_ACCOUNT"
      ],
      PARENT_COMPANY: [
        "USE_EXISTING",
        "NEW_ACCOUNT"
      ],
      HOUSEHOLD: [
        "USE_EXISTING"
      ],
      TENANT: [
        "USE_EXISTING",
        "SAME_ACCOUNT_DIFFERENT_ADDRESS"
      ],
      INDIVIDUAL_CLIENT: [
        "NEW_ACCOUNT"
      ],
      STAFF: []
    };


    let belongsSource = null;
    let belongsValue = null;
    let belongsLabel = null;
    let selectedBelongsRecord = null;

    function updateDynamicLabels(scenario) {
      const lblSame = document.getElementById("lblOptionSame");
      const lblDiff = document.getElementById("lblOptionDifferent");
      const lblSearch = document.getElementById("lblOptionSearch");
      
      const contactTitle = document.getElementById("contactSectionTitle");
      const lblContactNew = document.getElementById("lblContactNew");
      const lblContactSearch = document.getElementById("lblContactSearch");
      const lblContactUpdate = document.getElementById("lblContactUpdate");

      if (scenario === "TENANT") {
        if (lblSame) lblSame.textContent = "Select existing account at this address";
        if (lblDiff) lblDiff.textContent = "Add new billing address";
        if (lblSearch) lblSearch.textContent = "Search for billing address";
        
        if (contactTitle) contactTitle.textContent = "Tenant Details";
        if (lblContactNew) lblContactNew.textContent = "Create New Tenant";
        if (lblContactSearch) lblContactSearch.textContent = "Search Existing Tenant";
        if (lblContactUpdate) lblContactUpdate.textContent = "Update Existing Tenant";
      } else {
        if (lblSame) lblSame.textContent = "Use an existing account associated with the shipping address.";
        if (lblDiff) lblDiff.textContent = "Create a new account to associate with shipping address";
        if (lblSearch) lblSearch.textContent = "Search for a different account";
        
        if (contactTitle) contactTitle.textContent = "Contact Details";
        if (lblContactNew) lblContactNew.textContent = "Create New";
        if (lblContactSearch) lblContactSearch.textContent = "Search Existing";
        if (lblContactUpdate) lblContactUpdate.textContent = "Update Existing";
      }
    }

    function onBelongsToChange() {
      const select = document.getElementById("belongsTo");
      const billingOptions = document.getElementById("billingOptions");

      const selectedValue = select.value;

      // ===== FULL RESET =====
      selectedBillingOption = null;
      selectedBillingAccount = null;
      selectedBookingAccount = null;

      billingAccountUsage.mode = null;
      billingAccountUsage.sourceAccountId = null;

      // Hide ALL billing related UI
      billingOptions.classList.add("hidden");
      document.getElementById("billingSearchBox").classList.add("hidden");
      document.getElementById("manualBillingFields").classList.add("hidden");
      document.getElementById("billingContactSection").classList.add("hidden");
      document.getElementById("newLandlordDetails").classList.add("hidden");
      document.getElementById("billingAccountUsageBox").classList.add("hidden");
      document.getElementById("results").innerHTML = "";
      
      // Clear account details (but keep visible)
      clearAccountDetailsFields();

      // Clear billing option radios
      document.querySelectorAll('input[name="billingOption"]').forEach(r => {
        r.checked = false;
        r.closest(".billing-option")?.classList.remove("selected");
      });

      // Clear billing usage radios
      document.querySelectorAll('input[name="billingAccountUsage"]').forEach(r => {
        r.checked = false;
        r.closest(".billing-option")?.classList.remove("selected");
      });

      // Reset contact dropdown to "Create New"
      resetContactSelect();

      // ‚ùå Nothing selected ‚Üí STOP here
      if (!selectedValue) {
        belongsValue = null;
        belongsSource = null;
        belongsLabel = null;
        return;
      }

      // ‚úÖ Belongs To selected ‚Üí show billing options
      // DISABLED: Old billing options hidden - using new billingAddressOption dropdown
      // billingOptions.classList.remove("hidden");
      
      // Show billing address fields (for new billingAddressOption dropdown)
      document.getElementById("manualBillingFields").classList.remove("hidden");
      
      // Populate billing from lead and trigger dropdown change handler
      populateBillingFromLead();
      onBillingAddressOptionChange();

      const option = select.options[select.selectedIndex];
      belongsValue = option.value;
      belongsSource = option.dataset.source;
      belongsLabel = option.textContent;

      updateDynamicLabels(belongsValue);
      
      // Note: Contact Role manipulation removed - Billing Address doesn't have Contact Role field
      // The Shipping Address has its own contact role handling in onShippingBelongsToChange()
    }





    function clearSelectedBookingAccount() {
      selectedBookingAccount = null;

      document.querySelectorAll(".account-card").forEach(card => {
        card.classList.remove("selected");
        const radio = card.querySelector("input[type='radio']");
        if (radio) radio.checked = false;
      });
      
      // Reset contact dropdown when account is deselected
      resetContactSelect();
    }

    function highlightRadioGroup(name, value) {
      document
        .querySelectorAll(`input[name="${name}"]`)
        .forEach(r => r.closest(".billing-option")?.classList.remove("selected"));

      const radio = document.querySelector(
        `input[name="${name}"][value="${value}"]`
      );
      if (radio) {
        radio.closest(".billing-option").classList.add("selected");
      }
    }

    async function tryAutoSearchAccounts() {
      if (!shouldAutoSearchAccounts) return;

      if (
        !shipStreet.value.trim() ||
        !shipCity.value.trim() ||
        !shipProvince.value.trim() ||
        !shipPostal.value.trim() ||
        !shipCountry.value.trim()
      ) {
        return; // wait until full address exists
      }

      shouldAutoSearchAccounts = false; // run once

      document.getElementById("results").innerHTML =
        "Searching related accounts...";

      const accounts = await searchAccountsByAddress(shipStreet.value.trim());
      renderAccounts(accounts);
    }


    /*---------------- INIT ----------------- */
    if (typeof ZOHO !== "undefined" && ZOHO.embeddedApp) {
      ZOHO.embeddedApp.on("PageLoad", async function (data) {
        console.log("PageLoad event data", data);

        populateBelongsToDropdown();
        disableManualBillingEntry();
        initBillingRoleVisibility(); // Initialize BILLING role visibility


        // Increase the widget frame size inside CRM for a wider layout
        if (ZOHO.CRM && ZOHO.CRM.UI && ZOHO.CRM.UI.Resize) {
          ZOHO.CRM.UI.Resize({
            height: "90%"
          });
        }


        // Handle different data structures
        if (data.EntityId && Array.isArray(data.EntityId) && data.EntityId.length > 0) {
          currentLeadId = data.EntityId[0];
        } else if (data.EntityId) {
          currentLeadId = data.EntityId;
        } else if (data.RecordId) {
          currentLeadId = data.RecordId;
        }

        console.log("Resolved leadId:", currentLeadId);

        if (!currentLeadId) {
          alert("Lead ID missing. Please open this widget from a Lead record.");
          return;
        }

        // Optionally load lead details to pre-populate fields
        try {
          const leadData = await loadLeadDetails(currentLeadId);
          if (leadData && leadData.data && leadData.data[0]) {
            const lead = leadData.data[0];
            console.log("leadDetails", lead);

            // Pre-populate fields if needed
            if (lead.Company && accountSearch && !accountSearch.value) {
              accountSearch.value = lead.Company;
            }
            
            const lFirstName = lead.First_Name || "";
            const lLastName = lead.Last_Name || "";
            const lFullName = `${lFirstName} ${lLastName}`.trim();
            const lEmail = lead.Email || "";
            const lPhone = lead.Phone || lead.Mobile || "";

            initialLeadDetails = {
                name: lFullName,
                email: lEmail,
                phone: lPhone,
                company: lead.Company || "",
                // Shipping address from lead
                shipRoomLocation: lead.Room_Location || "",
                shipStreet: lead.Street || "",
                shipCity: lead.City || "",
                shipProvince: lead.State || "",
                shipPostal: lead.Zip_Code || "",
                shipCountry: lead.Country || "",
                // Billing address from lead
                billStreet: lead.Billing_Street || lead.Street || "",
                billCity: lead.Billing_City || lead.City || "",
                billProvince: lead.Billing_State || lead.State || "",
                billPostal: lead.Billing_Zip_Code || lead.Zip_Code || "",
                billCountry: lead.Billing_Country || lead.Country || ""
            };

            if (lFullName && !contactName.value) {
              contactName.value = lFullName;
            }
            if (lEmail && contactEmail && !contactEmail.value) {
              contactEmail.value = lEmail;
            }

            if (lPhone && contactPhone && !contactPhone.value) {
              contactPhone.value = formatPhoneDisplay(lPhone);
            }

            const shipAddr = getLeadAddress(lead);
            const billAddr = getLeadBillingAddress(lead);
            const hasBilling = hasAnyAddress(billAddr);



            // Pre-populate Shipping Address from lead
            shipStreet.value = lead.Street || "";
            shipCity.value = lead.City || "";
            shipProvince.value = lead.State || "";
            shipPostal.value = formatCanadianPostal(lead.Zip_Code) || "";
            shipCountry.value = lead.Country || "";
            
            // Pre-populate Contact Details from lead (show by default)
            document.getElementById("shippingContactFields").classList.remove("hidden");
            document.getElementById("shippingContactName").value = lFullName;
            document.getElementById("shippingContactEmail").value = lEmail;
            document.getElementById("shippingContactPhone").value = formatPhoneDisplay(lPhone);
            
            // Update Contact Details status to show "From Lead"
            const contactStatusEl = document.getElementById("shippingContactFieldsStatus");
            if (contactStatusEl) {
              contactStatusEl.textContent = "From Lead";
              contactStatusEl.style.background = "#fef3c7";
              contactStatusEl.style.color = "#92400e";
            }
            
            // Update Shipping Address status to show "From Lead"
            const addressStatusEl = document.getElementById("shippingAddressStatus");
            if (addressStatusEl) {
              addressStatusEl.textContent = "From Lead";
              addressStatusEl.style.background = "#fef3c7";
              addressStatusEl.style.color = "#92400e";
            }
            
            // Pre-populate Room Location from lead if available
            if (shipRoomLocation) {
              shipRoomLocation.value = lead.Room_Location || "";
            }
            
            // Populate shipping address dropdown with available addresses (based on email/phone and city)
            populateShippingAddressesFromContacts("");
            
            // Populate billing address dropdown with similar billing addresses from Accounts
            populateBillingAddressesFromAccounts();
            
            tryAutoSearchAccounts();
            console.log("shipStreet", shipStreet.value);
            console.log("shipCity", shipCity.value);
            console.log("shipProvince", shipProvince.value);
            console.log("shipPostal", shipPostal.value);

            // ================= BILLING =================
            // Always populate billing from initialLeadDetails (has fallback to shipping if no billing)
            if (sameAsShipping) sameAsShipping.checked = false;
              setBillingDisabled(false);
            
            // Use initialLeadDetails which has fallback logic (billing ‚Üí shipping)
            billStreet.value = initialLeadDetails.billStreet || "";
            billCity.value = initialLeadDetails.billCity || "";
            billProvince.value = initialLeadDetails.billProvince || "";
            billPostal.value = formatCanadianPostal(initialLeadDetails.billPostal) || "";
            billCountry.value = initialLeadDetails.billCountry || "";
            
            // Update billing status badge
            const billingStatusEl = document.getElementById("billingAddressStatus");
            if (billingStatusEl) {
              billingStatusEl.textContent = "From Lead";
              billingStatusEl.style.background = "#fef3c7";
              billingStatusEl.style.color = "#92400e";
            }
            
            console.log("Billing populated from lead:", {
              street: billStreet.value,
              city: billCity.value,
              province: billProvince.value,
              postal: billPostal.value,
              country: billCountry.value
            });

          }


        } catch (error) {
          console.error("Error loading lead details:", error);
        }
      });


      ZOHO.embeddedApp.init();
    }

    function showBillingAccountUsageOptions() {
      if (!belongsValue) return;

      // Hide the billing account usage options box (simplified flow)
      // const box = document.getElementById("billingAccountUsageBox");
      // box.classList.remove("hidden");

      // Apply rules for which options are allowed based on belongs to value
      const allowed = BILLING_USAGE_RULES[belongsValue] || [];
      document
        .querySelectorAll('input[name="billingAccountUsage"]')
        .forEach(radio => {
          radio.checked = false;
          radio.disabled = !allowed.includes(radio.value);
          radio.closest("label").style.opacity =
            allowed.includes(radio.value) ? "1" : "0.4";
        });

      // Directly show account details, contact details and billing address when account is selected
      if (selectedBookingAccount) {
        fetchAndShowAccountDetails(selectedBookingAccount);
        document.getElementById("accountDetailsFields").classList.remove("hidden");
        document.getElementById("billingContactSection").classList.remove("hidden");
        document.getElementById("manualBillingFields").classList.remove("hidden");
        enableManualBillingEntry();
        
        // Fetch contacts for the dropdown
        fetchRelatedContacts(selectedBookingAccount);
      }
    }


    function selectBillingAccountUsage(mode) {
      billingAccountUsage.mode = mode;

      // Show billing address fields for all modes
      document.getElementById("manualBillingFields").classList.remove("hidden");
      document.getElementById("newLandlordDetails").classList.add("hidden");

      // === ACCOUNT DETAILS LOGIC ===
        if (mode === "USE_EXISTING" || mode === "SAME_ACCOUNT_DIFFERENT_ADDRESS") {
        // Using existing account ‚Üí fetch and show account details
        if (selectedBookingAccount) {
          fetchAndShowAccountDetails(selectedBookingAccount);
        }
        document.getElementById("accountDetailsFields").classList.remove("hidden");
      } else if (mode === "NEW_ACCOUNT") {
        // Creating new account ‚Üí hide account details, will enter fresh info
        document.getElementById("accountDetailsFields").classList.add("hidden");
        clearAccountDetailsFields();
      }

      // === CONTACT DROPDOWN LOGIC ===
      if (mode === "USE_EXISTING" || mode === "SAME_ACCOUNT_DIFFERENT_ADDRESS") {
        // Using existing account ‚Üí populate contact dropdown with linked contacts
          if (selectedBookingAccount) {
            fetchRelatedContacts(selectedBookingAccount);
          }
        } else if (mode === "NEW_ACCOUNT") {
        // Creating new account ‚Üí reset to "Create New" contact
        resetContactSelect();
      }

      // Always enable billing fields for editing in all modes
        enableManualBillingEntry();
      
      // Show new landlord details for TENANT scenario when creating new account
      if (mode === "NEW_ACCOUNT" && belongsValue === "TENANT") {
             document.getElementById("newLandlordDetails").classList.remove("hidden");
      }

      // UI highlight
      document
        .querySelectorAll('#billingAccountUsageBox .billing-option')
        .forEach(opt => opt.classList.remove("selected"));

      const radio = document.querySelector(
        `input[name="billingAccountUsage"][value="${mode}"]`
      );
      if (radio) {
        radio.closest(".billing-option").classList.add("selected");
      }
    }

    // Helper function to reset contact select to "Create New" option
    function enableCreateNewContactForLandlord() {
      resetContactSelect();
    }

    // Helper function to reset contact select
    function resetAllContactModeOptions() {
      resetContactSelect();
    }

    // Helper function when using existing account - fetch contacts for dropdown
    function disableCreateNewContactForLandlord() {
      // When using existing account, the fetchRelatedContacts will populate the dropdown
      // User can still select "Create New" from dropdown if needed
    }



    function resetBelongsUI() {
      selectedBelongsRecord = null;

      document.getElementById("belongsSearchInput").value = "";
      document.getElementById("belongsSearchResults").innerHTML = "";
      document.getElementById("belongsSearchResults").classList.add("hidden");

      hideAttachedAccount();
    }

    function clearParentAccounts() {
      document.getElementById("results").innerHTML = "";
    }

    // Fetch a single account by ID
    async function fetchAccountById(accountId) {
      if (!accountId) return null;
      
      try {
        const query = `
          SELECT
            id,
            Account_Name,
            Account_Type,
            Phone,
            Website,
            Billing_Street,
            Billing_City,
            Billing_State,
            Billing_Country,
            Billing_Code
          FROM Accounts
          WHERE id = '${accountId}'
        `;

        const response = await ZOHO.CRM.API.coql({ select_query: query });
        
        if (response.data && response.data.length > 0) {
          return response.data[0];
        }
        
        return null;
      } catch (e) {
        console.error("Error fetching account by ID:", e);
        return null;
      }
    }

    async function searchAccountsByAddress(address) {

      try {
        let allServiceLocation = await ZOHO.CRM.API.getRecord({
          Entity: "Service_Locations",
        });

        console.log("all service location", allServiceLocation);


        if (!address) return [];
        console.log("address", address);

        console.log("address two", `${address}, ${shipCity.value}, ${shipProvince.value}, ${shipCountry.value}, ${shipPostal.value}`);

        const queryServiceLocation = `
              SELECT id, Account, Address_Type, Name, Street, City, State, Zip_Code, Country
              FROM Service_Locations
              WHERE Street = '${address}' AND City = '${shipCity.value}' AND State = '${shipProvince.value}'
              LIMIT 20
      `;

        const responseServiceLocation = await ZOHO.CRM.API.coql({ select_query: queryServiceLocation });

        const serviceLocationData = Array.isArray(responseServiceLocation?.data)
          ? responseServiceLocation.data
          : [];

        const serviceLocations = responseServiceLocation.data || [];
        const accountIds = [
          ...new Set(
            serviceLocations
              .map(sl => sl?.Account?.id)
              .filter(Boolean)
          )
        ];

        console.log("Account IDs:", accountIds);

        const accountIdList = accountIds.map(id => `'${id}'`).join(",");

        const whereClause = accountIds
          .map(id => `id = '${id}'`)
          .join(" OR ");


        const accountDetailsQuery = `
          SELECT
            id,
            Account_Name,
            Account_Type,
            Phone,
            Website,
            Billing_Street,
            Billing_City,
            Billing_State,
            Billing_Country,
            Billing_Code
          FROM Accounts
          WHERE ${whereClause} 
        `;

        let accountDetails = [];

        if (accountIds.length > 0) {
          const accountResponse = await ZOHO.CRM.API.coql({
            select_query: accountDetailsQuery
          });

          accountDetails = Array.isArray(accountResponse?.data)
            ? accountResponse.data
            : [];
        }

        console.log("Full Account Details:", accountDetails);



        const query = `
              SELECT id, Account_Name, Account_Type, Shipping_Street, Shipping_City
              FROM Accounts
              WHERE Shipping_Street = '%${address}%'
              LIMIT 20
    `;



        const response = await ZOHO.CRM.API.coql({ select_query: query });
        console.log("query one", response);

        console.log("service location value - ", responseServiceLocation);

        const accountsData = Array.isArray(response?.data)
          ? response.data
          : [];

        console.log(accountsData, accountDetails);

        // ‚úÖ Merge safely
        const allResponse = [...accountsData, ...accountDetails];

        console.log("all response", allResponse);

        return allResponse;

      } catch (error) {
        console.log("error while getting all address", error);

      }
    }

    function formatBillingAddress(acc) {
      const parts = [
        safe(acc.Billing_Street),
        safe(acc.Billing_City),
        safe(acc.Billing_State),
        safe(acc.Billing_Country),
        safe(acc.Billing_Code)
      ].filter(Boolean);

      return parts.length
        ? parts.join(", ")
        : "Billing address not available";
    }

    function safe(val) {
      return val && typeof val === "string" && val.trim() ? val.trim() : null;
    }


    function renderAccounts(accounts) {
      const container = document.getElementById("results");
      container.innerHTML = "";

      if (!Array.isArray(accounts) || accounts.length === 0) {
        container.innerHTML =
          "<p style='color:#64748b;'>No related accounts found.</p>";
        return;
      }

      accounts.forEach((acc, index) => {
        const accountId = acc.id;
        const accountName = safe(acc.Account_Name) || `Unnamed Account ${index + 1}`;
        const billingAddress = formatBillingAddress(acc);

        container.innerHTML += `
       <div class="account-card" data-id="${accountId}"
       onclick="toggleBookingAccount('${accountId}')">

    <div class="account-radio">
      <input type="radio" name="bookingAccount" />
    </div>

    <div class="account-content">
      <div class="account-name">${accountName}</div>

      <div class="account-address">
        <strong>Billing Address</strong><br/>
        ${billingAddress}
      </div>
    </div>
  </div>

    `;
      });
    }

    function toggleBookingAccount(accountId) {
      // If clicking the already-selected account ‚Üí DESELECT
      if (selectedBookingAccount === accountId) {
        clearSelectedBookingAccount();
        selectedBookingAccount = null;
        return;
      }

      // Otherwise ‚Üí select normally
      selectBookingAccount(accountId);
    }


    function selectBookingAccount(accountId) {
      // Clear previous selection UI
      document.querySelectorAll(".account-card").forEach(card => {
        card.classList.remove("selected");
        const radio = card.querySelector("input[type='radio']");
        if (radio) radio.checked = false;
      });

      const card = document.querySelector(
        `.account-card[data-id="${accountId}"]`
      );
      if (!card) return;

      card.classList.add("selected");
      card.querySelector("input[type='radio']").checked = true;

      // Set selected account
      selectedBookingAccount = accountId;
      selectedBillingAccount = accountId;

      billingAccountUsage.sourceAccountId = accountId;

      // Show usage options for both SAME and SEARCH options when account is selected
      if ((selectedBillingOption === "SEARCH" || selectedBillingOption === "SAME") && shouldShowBillingUsage()) {
        showBillingAccountUsageOptions();
      }

      // === LANDLORD: Disable "Create New" contact when existing account is selected ===
      if (belongsValue === "LANDLORD" && (selectedBillingOption === "SAME" || selectedBillingOption === "SEARCH")) {
        // User selected existing account ‚Üí must use existing contact from that account
        disableCreateNewContactForLandlord();
      }

      // Show billing address fields and populate with selected account's billing address
      // Note: fetchRelatedContacts is called in showBillingAccountUsageOptions, no need to call again
      fetchAndShowBillingAddress(accountId);
    }

    // Store account data for reuse when switching modes
    let cachedAccountData = null;

    async function fetchAndShowBillingAddress(accountId) {
      if (!accountId) return;

      try {
        const response = await ZOHO.CRM.API.getRecord({
          Entity: "Accounts",
          RecordID: accountId
        });

        if (response.data && response.data[0]) {
          const acc = response.data[0];
          
          // Cache the account data for reuse
          cachedAccountData = acc;
          
          // Populate account details fields
          populateAccountDetailsFields(acc);
          
          // Show account details section
          document.getElementById("accountDetailsFields").classList.remove("hidden");
          
          // Populate billing address fields
          billStreet.value = acc.Billing_Street || "";
          billCity.value = acc.Billing_City || "";
          billProvince.value = acc.Billing_State || "";
          billPostal.value = formatCanadianPostal(acc.Billing_Code) || "";
          billCountry.value = acc.Billing_Country || "";

          // Show billing address fields and enable editing
          document.getElementById("manualBillingFields").classList.remove("hidden");
          enableManualBillingEntry();
        }
      } catch (error) {
        console.error("Error fetching account billing address:", error);
      }
    }

    // Fetch and populate account details (without changing billing address)
    async function fetchAndShowAccountDetails(accountId) {
      if (!accountId) return;

      // If we have cached data for this account, use it
      if (cachedAccountData && cachedAccountData.id === accountId) {
        populateAccountDetailsFields(cachedAccountData);
        return;
      }

      try {
        const response = await ZOHO.CRM.API.getRecord({
          Entity: "Accounts",
          RecordID: accountId
        });

        if (response.data && response.data[0]) {
          const acc = response.data[0];
          cachedAccountData = acc;
          populateAccountDetailsFields(acc);
        }
      } catch (error) {
        console.error("Error fetching account details:", error);
      }
    }

    // Helper function to populate account details fields
    function populateAccountDetailsFields(acc) {
      const accountNameEl = document.getElementById("accountName");
      const accountPhoneEl = document.getElementById("accountPhone");
      const accountEmailEl = document.getElementById("accountEmail");
      
      if (accountNameEl) accountNameEl.value = acc.Account_Name || "";
      if (accountPhoneEl) accountPhoneEl.value = formatPhoneDisplay(acc.Phone) || "";
      if (accountEmailEl) accountEmailEl.value = acc.Email || "";
      
      // Update status badge
      updateAccountDetailsStatus("Existing Account", "#dcfce7", "#166534");
    }

    // Populate account details from lead details (for new account)
    function populateAccountDetailsFromLead() {
      const accountNameEl = document.getElementById("accountName");
      const accountPhoneEl = document.getElementById("accountPhone");
      const accountEmailEl = document.getElementById("accountEmail");
      
      // Use lead company name or contact name as account name
      const accountName = initialLeadDetails.company || initialLeadDetails.name || "";
      
      if (accountNameEl) accountNameEl.value = accountName;
      if (accountPhoneEl) accountPhoneEl.value = formatPhoneDisplay(initialLeadDetails.phone) || "";
      if (accountEmailEl) accountEmailEl.value = initialLeadDetails.email || "";
      
      // Update status badge
      updateAccountDetailsStatus("New Account", "#dbeafe", "#1d4ed8");
    }

    // Clear account details fields
    function clearAccountDetailsFields() {
      const accountNameEl = document.getElementById("accountName");
      const accountPhoneEl = document.getElementById("accountPhone");
      const accountEmailEl = document.getElementById("accountEmail");
      
      if (accountNameEl) accountNameEl.value = "";
      if (accountPhoneEl) accountPhoneEl.value = "";
      if (accountEmailEl) accountEmailEl.value = "";
      
      // Update status badge
      updateAccountDetailsStatus("Select an option", "#e2e8f0", "#64748b");
    }

    // Update account details status badge
    function updateAccountDetailsStatus(text, bgColor, textColor) {
      const statusEl = document.getElementById("accountDetailsStatus");
      if (statusEl) {
        statusEl.textContent = text;
        statusEl.style.background = bgColor;
        statusEl.style.color = textColor;
      }
    }

    // Store fetched contacts for later use
    let accountLinkedContacts = [];

    async function fetchRelatedContacts(accountId) {
      const contactSelect = document.getElementById("contactSelect");
      if (!contactSelect) return;
      
      // Reset select to only "Create New" option
      contactSelect.innerHTML = '<option value="NEW">+ Create New Contact</option>';
      accountLinkedContacts = [];

      if (!accountId) return;

      try {
        const related = await ZOHO.CRM.API.getRelatedRecords({
          Entity: "Accounts",
          RecordID: accountId,
          RelatedList: "Contacts",
          page: 1,
          per_page: 20
        });
        
        if (!related.data || related.data.length === 0) {
          // No contacts found - just show "Create New" option
           return;
        }

        // Store contacts for later reference
        accountLinkedContacts = related.data;

        // Add a separator
        const separator = document.createElement("option");
        separator.disabled = true;
        separator.textContent = "‚îÄ‚îÄ‚îÄ‚îÄ Linked Contacts ‚îÄ‚îÄ‚îÄ‚îÄ";
        contactSelect.appendChild(separator);

        // Add each contact as an option
        related.data.forEach(c => {
          const name = c.Full_Name || `${c.First_Name || ""} ${c.Last_Name || ""}`.trim();
          const email = c.Email || "";
          
          const option = document.createElement("option");
          option.value = c.id;
          option.textContent = email ? `${name} (${email})` : name;
          option.dataset.contactData = JSON.stringify(c);
          contactSelect.appendChild(option);
        });

        // Update hint
        const hint = document.getElementById("contactSelectHint");
        if (hint) {
          hint.textContent = `${related.data.length} contact(s) linked to this account`;
        }

      } catch (e) {
        console.error("Error fetching related contacts", e);
      }
    }

    function onContactSelectChange() {
      const contactSelect = document.getElementById("contactSelect");
      const selectedValue = contactSelect.value;
      const warningBox = document.getElementById("contactUpdateWarning");

      if (selectedValue === "NEW") {
        // Create new contact - clear fields and enable editing
        selectedContact = null;
        contactName.value = initialLeadDetails.name || "";
        contactEmail.value = initialLeadDetails.email || "";
        contactPhone.value = formatPhoneDisplay(initialLeadDetails.phone) || "";
        
        // Enable all fields for new contact
        contactName.disabled = false;
        contactEmail.disabled = false;
        contactPhone.disabled = false;

        // Hide update warning for new contacts
        if (warningBox) warningBox.classList.add("hidden");
      } else {
        // Existing contact selected - find and populate
        const selectedOption = contactSelect.options[contactSelect.selectedIndex];
        if (selectedOption && selectedOption.dataset.contactData) {
          const contactData = JSON.parse(selectedOption.dataset.contactData);
          selectContactFromDropdown(contactData);
        }
      }
    }

    function selectContactFromDropdown(c) {
      selectedContact = c;
      
      const name = c.Full_Name || `${c.First_Name || ""} ${c.Last_Name || ""}`.trim();
      const email = c.Email || c.Email_Address || "";
      const phone = c.Phone || c.Mobile || "";

      contactName.value = name;
      contactEmail.value = email;
      contactPhone.value = formatPhoneDisplay(phone);

      // Enable fields for editing (user can update existing contact)
      contactName.disabled = false;
      contactEmail.disabled = false;
      contactPhone.disabled = false;

      // Show update warning for existing contacts
      const warningBox = document.getElementById("contactUpdateWarning");
      if (warningBox) warningBox.classList.remove("hidden");
    }

    function resetContactSelect() {
      const contactSelect = document.getElementById("contactSelect");
      if (contactSelect) {
        contactSelect.innerHTML = '<option value="NEW">+ Create New Contact</option>';
        contactSelect.value = "NEW";
      }
      accountLinkedContacts = [];
      selectedContact = null;
      
      // Reset to lead details
      contactName.value = initialLeadDetails.name || "";
      contactEmail.value = initialLeadDetails.email || "";
      contactPhone.value = formatPhoneDisplay(initialLeadDetails.phone) || "";
      
      // Enable fields
      contactName.disabled = false;
      contactEmail.disabled = false;
      contactPhone.disabled = false;

      // Update hint
      const hint = document.getElementById("contactSelectHint");
      if (hint) {
        hint.textContent = "Select an existing contact or create a new one";
      }

      // Hide update warning
      const warningBox = document.getElementById("contactUpdateWarning");
      if (warningBox) warningBox.classList.add("hidden");
    }

    // Clear billing contact fields
    function clearContactFields() {
      const contactNameEl = document.getElementById("contactName");
      const contactEmailEl = document.getElementById("contactEmail");
      const contactPhoneEl = document.getElementById("contactPhone");
      
      if (contactNameEl) contactNameEl.value = "";
      if (contactEmailEl) contactEmailEl.value = "";
      if (contactPhoneEl) contactPhoneEl.value = "";
      
      // Hide warning
      const warningBox = document.getElementById("contactUpdateWarning");
      if (warningBox) warningBox.classList.add("hidden");
    }

    /* ========== SHIPPING ADDRESS SECTION FUNCTIONS ========== */

    let shippingSelectedContact = null;
    let shippingSelectedAddress = null;
    let shippingLinkedContacts = [];
    let shippingLinkedAddresses = [];

    function onShippingBelongsToChange() {
      const belongsTo = document.getElementById("shippingBelongsTo").value;
      
      // Reset shipping address dropdown
      document.getElementById("shippingAddressOption").value = "";
      
      shippingSelectedContact = null;
      shippingSelectedAddress = null;

      // Show/hide "Billing same as Shipping" checkbox based on parent position
      const billingSameCheckboxContainer = document.getElementById("billingSameAsShipping")?.parentElement?.parentElement;
      if (billingSameCheckboxContainer) {
        if (belongsTo && isParentPosition(belongsTo)) {
          // Parent position - show checkbox
          billingSameCheckboxContainer.style.display = '';
        } else {
          // Child position or no selection - hide checkbox and uncheck it
          billingSameCheckboxContainer.style.display = 'none';
          const checkbox = document.getElementById("billingSameAsShipping");
          if (checkbox && checkbox.checked) {
            checkbox.checked = false;
            onBillingSameAsShippingChange(); // Trigger to reset billing section
          }
        }
      }

      // Always show contact details and shipping address, pre-fill with lead data
      document.getElementById("shippingContactFields").classList.remove("hidden");
      document.getElementById("shippingAddressFields").classList.remove("hidden");
      populateShippingContactFromLead();
      populateShippingFromLeadDetails();
      
      // Contact details remain visible with lead data
      document.getElementById("shippingContactFieldsTitle").textContent = "Contact Details";

      // Pre-select role based on belongs to
      const tenantCheckbox = document.querySelector('#roleDropdown input[value="TENANT"]');
      if (tenantCheckbox) {
        tenantCheckbox.checked = belongsTo === "TENANT";
        updateRoles();
      }

      // Fetch and populate shipping addresses from contacts (even if no belongs to selected)
      populateShippingAddressesFromContacts(belongsTo || "");
    }

    // Populate shipping addresses from contacts (email/phone match, similar addresses, and by type)
    async function populateShippingAddressesFromContacts(belongsToType) {
      const addressSelect = document.getElementById("shippingAddressOption");
      const hintEl = document.getElementById("shippingAddressOptionHint");
      
      // Reset dropdown
      addressSelect.innerHTML = `
        <option value="">Select</option>
        <option value="CREATE_NEW">+ Create New Shipping Address</option>
        <option value="SEARCH_ADDRESS">üîç Search Address</option>
      `;

      // Map belongs to value to contact type/role
      const contactTypeMap = {
        "LANDLORD": "Landlord",
        "PARENT_COMPANY": "Parent Company",
        "PROPERTY_MANAGEMENT": "Property Management",
        "SUBCONTRACTOR": "Subcontractor",
        "DIRECT_CLIENT": "Direct Client",
        "HOUSEHOLD": "Household",
        "TENANT": "Tenant",
        "INDIVIDUAL_CLIENT": "Individual Client",
        "STAFF": "Staff"
      };

      const searchType = contactTypeMap[belongsToType] || belongsToType;
      let totalAddressCount = 0;
      const addedContactIds = new Set(); // Track added contacts to avoid duplicates

      // Get lead details for matching
      const leadEmail = initialLeadDetails.email || "";
      const leadPhone = initialLeadDetails.phone || "";
      const leadCity = initialLeadDetails.shipCity || "";
      const leadStreet = initialLeadDetails.shipStreet || "";
      
      // Extract key words from street for fuzzy matching (words > 2 chars)
      const streetWords = leadStreet.split(/[\s,]+/).filter(word => word.length > 2);

      try {
        // ========== SECTION 1: Addresses Linked to Lead's Email/Phone ==========
        // Find contacts by email/phone, then get their Service Locations via Junction Module
        console.log("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ");
        console.log("üìß SECTION 1: Searching addresses by Email/Phone");
        console.log("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ");
        console.log("Lead Email:", leadEmail || "(empty)");
        console.log("Lead Phone:", leadPhone || "(empty)");
        
        if (leadEmail || leadPhone) {
          let contactCriteria = [];
          if (leadEmail) contactCriteria.push(`(Email:equals:${leadEmail})`);
          if (leadPhone) {
            contactCriteria.push(`(Phone:equals:${leadPhone})`);
            contactCriteria.push(`(Mobile:equals:${leadPhone})`);
          }
          
          const contactQuery = contactCriteria.join(" or ");
          console.log("üìã Contact Search Query:", contactQuery);
          
          try {
            const contactRes = await ZOHO.CRM.API.searchRecord({
          Entity: "Contacts",
          Type: "criteria",
              Query: contactQuery,
              per_page: 50
            });

            console.log("üì• Contact Search Response:", contactRes);
            
            if (contactRes.data && contactRes.data.length > 0) {
              console.log(`‚úÖ Found ${contactRes.data.length} contact(s) matching email/phone`);
              let sectionHasAddresses = false;
              const sectionOptions = []; // Collect options first to check if any exist

              for (const contact of contactRes.data) {
          const name = contact.Full_Name || `${contact.First_Name || ""} ${contact.Last_Name || ""}`.trim();
          const email = contact.Email || "";
          const phone = contact.Phone || contact.Mobile || "";
                
                console.log(`\nüë§ Processing Contact: ${name} (ID: ${contact.id})`);
                console.log(`   Email: ${email}, Phone: ${phone}`);
                
                // Query Junction Module (Contact_Service_Locations) to get linked Service Locations
                try {
                  const junctionQuery = `
                    SELECT Contact_Type, 
                           Service_Location.id, Service_Location.Name, Service_Location.Room_Location,
                           Service_Location.Province, Service_Location.Street, Service_Location.City,
                           Service_Location.Postal_Code, Service_Location.Country, Service_Location.Account
                    FROM Contact_Service_Location
                    WHERE Contact = '${contact.id}'
                    LIMIT 30
                  `;

                  console.log("üìã Junction Query:", junctionQuery.trim());
                  const junctionRes = await ZOHO.CRM.API.coql({ select_query: junctionQuery });
                  console.log("üì• Junction Response:", junctionRes);
                  
                  if (junctionRes.data && junctionRes.data.length > 0) {
                    console.log(`   ‚úÖ Found ${junctionRes.data.length} junction record(s)`);
                    const addedLocations = new Set();
                    
                    junctionRes.data.forEach((junction, idx) => {
                      // COQL returns flat properties like "Service_Location.City" instead of nested object
                      // Extract service location data from flat properties
                      const serviceLocId = junction["Service_Location.id"] || (junction.Service_Location && junction.Service_Location.id);
                      const serviceLocName = junction["Service_Location.Name"] || (junction.Service_Location && junction.Service_Location.Name) || "";
                      const serviceLocRoomLocation = junction["Service_Location.Room_Location"] || (junction.Service_Location && junction.Service_Location.Room_Location) || "";
                      const serviceLocStreet = junction["Service_Location.Street"] || (junction.Service_Location && junction.Service_Location.Street) || "";
                      const serviceLocCity = junction["Service_Location.City"] || (junction.Service_Location && junction.Service_Location.City) || "";
                      const serviceLocProvince = junction["Service_Location.Province"] || junction["Service_Location.State"] || (junction.Service_Location && (junction.Service_Location.Province || junction.Service_Location.State)) || "";
                      const serviceLocPostal = junction["Service_Location.Postal_Code"] || junction["Service_Location.Zip_Code"] || (junction.Service_Location && (junction.Service_Location.Postal_Code || junction.Service_Location.Zip_Code)) || "";
                      const serviceLocCountry = junction["Service_Location.Country"] || (junction.Service_Location && junction.Service_Location.Country) || "";
                      
                      // Extract Account ID from Service Location
                      const serviceLocAccountRaw = junction["Service_Location.Account"] || (junction.Service_Location && junction.Service_Location.Account);
                      const serviceLocAccountId = serviceLocAccountRaw ? (serviceLocAccountRaw.id || serviceLocAccountRaw) : "";
                      const serviceLocAccountName = serviceLocAccountRaw ? (serviceLocAccountRaw.name || "") : "";
                      
                      console.log(`   üìç Junction #${idx + 1}:`, {
                        Contact_Type: junction.Contact_Type,
                        ServiceLocId: serviceLocId,
                        AccountId: serviceLocAccountId,
                        RoomLocation: serviceLocRoomLocation,
                        Street: serviceLocStreet,
                        City: serviceLocCity,
                        Province: serviceLocProvince
                      });
                      
                      if (serviceLocId && !addedLocations.has(serviceLocId)) {
                        addedLocations.add(serviceLocId);
                        
                        const role = junction.Contact_Type || "Contact";
                        // Include Room Location in address text if present
                        const streetWithRoom = serviceLocRoomLocation 
                          ? `${serviceLocRoomLocation}, ${serviceLocStreet}` 
                          : serviceLocStreet;
                        const addressText = [streetWithRoom, serviceLocCity, serviceLocProvince, serviceLocPostal].filter(Boolean).join(", ") || serviceLocName || "Service Location";
                        
                        // Only add if there's actual address data
                        if (serviceLocStreet || serviceLocCity) {
                          console.log(`      ‚úÖ Adding address: ${addressText} [${role}] - Account: ${serviceLocAccountId}`);
                          const option = document.createElement("option");
                          option.value = `SL_${serviceLocId}`;
                          option.textContent = `üìç ${addressText} - ${name} [${role}]`;
                          option.dataset.contactData = JSON.stringify({
                            id: contact.id,
                            name: name,
                            email: email,
                            phone: phone,
                            role: role,
                            serviceLocationId: serviceLocId,
                            accountId: serviceLocAccountId,
                            accountName: serviceLocAccountName,
                            roomLocation: serviceLocRoomLocation,
                            street: serviceLocStreet,
                            city: serviceLocCity,
                            province: serviceLocProvince,
                            postalCode: serviceLocPostal,
                            country: serviceLocCountry,
                            source: "contact_email_phone"
                          });
                          sectionOptions.push(option);
                          addedContactIds.add(contact.id);
                          sectionHasAddresses = true;
                        } else {
                          console.log(`      ‚ö†Ô∏è Skipping - No Street or City in Service Location`);
                        }
                      } else if (!serviceLocId) {
                        console.log(`      ‚ö†Ô∏è Skipping - No Service Location ID`);
                      } else if (addedLocations.has(serviceLocId)) {
                        console.log(`      ‚ö†Ô∏è Skipping - Duplicate location`);
                      }
                    });
                  } else {
                    console.log(`   ‚ö†Ô∏è No junction records found for this contact`);
                    console.log(`   Tip: Create a Contact_Service_Locations record linking this contact to a Service Location`);
                  }
                } catch (junctionErr) {
                  console.error("‚ùå Error fetching junction records for contact:", junctionErr);
                }
              }

              // Only add separator and options if we found addresses
              if (sectionHasAddresses && sectionOptions.length > 0) {
                console.log(`\n‚úÖ SECTION 1 RESULT: Adding ${sectionOptions.length} address(es) to dropdown`);
                const separator = document.createElement("option");
                separator.disabled = true;
                separator.textContent = "‚îÄ‚îÄ Addresses Linked to Your Email/Phone ‚îÄ‚îÄ";
                addressSelect.appendChild(separator);
                
                sectionOptions.forEach(opt => {
                  addressSelect.appendChild(opt);
                  totalAddressCount++;
                });
              } else {
                console.log("\n‚ö†Ô∏è SECTION 1 RESULT: No addresses found to add");
              }
            } else {
              console.log("‚ö†Ô∏è No contacts found matching the email/phone");
            }
          } catch (contactErr) {
            console.error("‚ùå Error searching contacts by email/phone:", contactErr);
          }
        } else {
          console.log("‚ö†Ô∏è Skipping Section 1 - Lead has no email or phone");
        }
        console.log("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n");

        // ========== SECTION 2: Similar Addresses (Same Postal Code + Similar Room/Street) ==========
        console.log("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ");
        console.log("üìå SECTION 2: Finding Similar Addresses by Postal Code");
        console.log("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ");
        const leadPostal = initialLeadDetails.shipPostal || "";
        console.log("Lead Postal Code:", leadPostal || "(empty)");
        console.log("Lead Street:", leadStreet || "(empty)");
        console.log("Street Words for matching:", streetWords);
        
        // Also extract room location words from lead if available
        const leadRoomLocation = initialLeadDetails.shipRoomLocation || "";
        const roomWords = leadRoomLocation.split(/[\s,]+/).filter(word => word.length > 1);
        console.log("Lead Room Location:", leadRoomLocation || "(empty)");
        console.log("Room Words for matching:", roomWords);
        
        if (leadPostal && leadPostal.trim()) {
          try {
            const postalQuery = `
              SELECT id, Name, Room_Location, Street, City, Province, Postal_Code, Country, Account
              FROM Service_Locations
              WHERE Postal_Code = '${leadPostal.trim()}'
              LIMIT 50
            `;
            
            console.log("üìã Postal Code Query:", postalQuery.trim());
            const postalRes = await ZOHO.CRM.API.coql({ select_query: postalQuery });
            console.log("üì• Postal Code Query Response:", postalRes);

            if (postalRes.data && postalRes.data.length > 0) {
              console.log(`‚úÖ Found ${postalRes.data.length} Service Location(s) with postal code ${leadPostal}`);
              
              // Show ALL addresses from the same postal code (no filtering)
              const allPostalAddresses = postalRes.data;

              console.log(`‚úÖ Showing all ${allPostalAddresses.length} address(es) with postal code ${leadPostal}`);

              if (allPostalAddresses.length > 0) {
                // Add separator
                const nearbySeparator = document.createElement("option");
                nearbySeparator.disabled = true;
                const streetHint = leadStreet ? `, near ${leadStreet.substring(0, 20)}${leadStreet.length > 20 ? "..." : ""}` : "";
                nearbySeparator.textContent = `‚îÄ‚îÄ Addresses in ${leadPostal}${streetHint} ‚îÄ‚îÄ`;
                addressSelect.appendChild(nearbySeparator);

                allPostalAddresses.forEach((loc, idx) => {
                  const locRoomLocation = loc.Room_Location || "";
                  const locStreet = loc.Street || "";
                  const locCity = loc.City || "";
                  const locProvince = loc.Province || loc.State || "";
                  const locPostalCode = loc.Postal_Code || loc.Zip_Code || "";
                  const locCountry = loc.Country || "";
                  
                  // Build address text with room location if present
                  const streetWithRoom = locRoomLocation 
                    ? `${locRoomLocation}, ${locStreet}` 
                    : locStreet;
                  const addressText = [streetWithRoom, locCity, locProvince, locPostalCode].filter(Boolean).join(", ") || loc.Name || "Service Location";
                  
                  // Determine match type for label
                  const locStreetLower = locStreet.toLowerCase();
                  const locRoomLower = locRoomLocation.toLowerCase();
                  const hasStreetMatch = streetWords.some(word => locStreetLower.includes(word.toLowerCase()));
                  const hasRoomMatch = roomWords.some(word => locRoomLower.includes(word.toLowerCase()));
                  
                  let matchLabel = "Same Postal Code";
                  if (hasStreetMatch && hasRoomMatch) {
                    matchLabel = "Similar Street & Room";
                  } else if (hasStreetMatch) {
                    matchLabel = "Similar Street";
                  } else if (hasRoomMatch) {
                    matchLabel = "Similar Room";
                  }
                  
                  // Get Account info from Service Location
                  const locAccountId = loc.Account ? (loc.Account.id || loc.Account) : "";
                  const locAccountName = loc.Account ? (loc.Account.name || "") : "";
                  
                  console.log(`   üìå #${idx + 1}: ${addressText} [${matchLabel}] - Account: ${locAccountId}`);
                  
          const option = document.createElement("option");
                  option.value = `SIMILAR_${loc.id}`;
                  option.textContent = `üìå ${addressText} [${matchLabel}]`;
                  option.dataset.contactData = JSON.stringify({
                    id: null,
                    name: "",
                    email: "",
                    phone: "",
                    role: matchLabel,
                    serviceLocationId: loc.id,
                    accountId: locAccountId,
                    accountName: locAccountName,
                    roomLocation: locRoomLocation,
                    street: locStreet,
                    city: locCity,
                    province: locProvince,
                    postalCode: locPostalCode,
                    country: locCountry,
                    source: "similar_address"
          });
          addressSelect.appendChild(option);
                  totalAddressCount++;
                });
                
                console.log(`\n‚úÖ SECTION 2 RESULT: Added ${allPostalAddresses.length} address(es) with postal code ${leadPostal}`);
              } else {
                console.log("‚ö†Ô∏è SECTION 2 RESULT: No addresses found with postal code");
              }
            } else {
              console.log(`‚ö†Ô∏è No Service Locations found with postal code: ${leadPostal}`);
            }
          } catch (postalErr) {
            console.error("‚ùå Error fetching similar addresses:", postalErr);
          }
        } else {
          console.log("‚ö†Ô∏è Skipping Section 2 - Lead has no postal code");
        }
        console.log("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n");

        // ========== SECTION 3: Contacts by Belongs To Type (Original) ==========
        const typeCriteria = `(Contact_Type:equals:${searchType})`;
        
        const typeRes = await ZOHO.CRM.API.searchRecord({
          Entity: "Contacts",
                Type: "criteria",
          Query: typeCriteria,
          per_page: 30
        });

        if (typeRes.data && typeRes.data.length > 0) {
          // Filter out contacts already added from email/phone search
          const newContacts = typeRes.data.filter(c => !addedContactIds.has(c.id));
          
          if (newContacts.length > 0) {
            // Add separator
            const typeSeparator = document.createElement("option");
            typeSeparator.disabled = true;
            typeSeparator.textContent = `‚îÄ‚îÄ Other ${searchType} Contacts ‚îÄ‚îÄ`;
            addressSelect.appendChild(typeSeparator);

            newContacts.forEach(contact => {
              const name = contact.Full_Name || `${contact.First_Name || ""} ${contact.Last_Name || ""}`.trim();
              const email = contact.Email || "";
              const phone = contact.Phone || contact.Mobile || "";
              const street = contact.Mailing_Street || contact.Other_Street || "";
              const city = contact.Mailing_City || contact.Other_City || "";
              const state = contact.Mailing_State || contact.Other_State || "";
              const postalCode = contact.Mailing_Zip || contact.Other_Zip || "";
              const country = contact.Mailing_Country || contact.Other_Country || "";
              
              const addressParts = [street, city, state].filter(Boolean);
              const addressText = addressParts.length > 0 ? addressParts.join(", ") : "No address";
              
                        const option = document.createElement("option");
              option.value = `TYPE_${contact.id}`;
              option.textContent = `üë§ ${addressText} - ${name} [${searchType}]`;
              option.dataset.contactData = JSON.stringify({
                id: contact.id,
                name: name,
                email: email,
                phone: phone,
                role: searchType,
                street: street,
                city: city,
                province: state,
                postalCode: postalCode,
                country: country,
                source: "contact_type"
                        });
                        addressSelect.appendChild(option);
              totalAddressCount++;
            });
          }
          
          shippingLinkedContacts = typeRes.data;
        } else {
          shippingLinkedContacts = [];
        }

        // Update hint
        if (hintEl) {
          hintEl.textContent = totalAddressCount > 0 
            ? `${totalAddressCount} address(es) found`
            : "No addresses found. Create new.";
        }

      } catch (err) {
        console.error("Error fetching addresses:", err);
        if (hintEl) hintEl.textContent = "Error loading addresses. Create new.";
        shippingLinkedContacts = [];
      }
    }

    // ========== ADDRESS SEARCH FUNCTIONS ==========
    let addressSearchTimeout = null;
    
    // Debounce address search input
    function debounceAddressSearch() {
      clearTimeout(addressSearchTimeout);
      const searchInput = document.getElementById("addressSearchInput");
      const hintEl = document.getElementById("addressSearchHint");
      
      if (searchInput.value.length < 3) {
        if (hintEl) hintEl.textContent = "Type at least 3 characters to search";
        const resultsEl = document.getElementById("addressSearchResults");
        if (resultsEl) {
          resultsEl.innerHTML = "";
          resultsEl.classList.add("hidden");
        }
        return;
      }
      
      if (hintEl) hintEl.textContent = "Searching...";
      
      addressSearchTimeout = setTimeout(() => {
        performAddressSearch();
      }, 400);
    }
    
    // Perform address search against Service_Locations
    async function performAddressSearch() {
      const searchInput = document.getElementById("addressSearchInput");
      const resultsEl = document.getElementById("addressSearchResults");
      const hintEl = document.getElementById("addressSearchHint");
      
      const searchTerm = searchInput?.value?.trim() || "";
      
      if (searchTerm.length < 3) {
        if (hintEl) hintEl.textContent = "Type at least 3 characters to search";
        return;
      }
      
      console.log("üîç Searching addresses for:", searchTerm);
      
      try {
        // Escape single quotes in search term for COQL query
        const escapedTerm = searchTerm.replace(/'/g, "\\'");
        
        // Search by Name (COQL only supports LIKE on certain fields)
        // Valid COQL syntax: field like 'value%' for starts-with
        const searchQuery = `SELECT
              id,
              Name,
              Room_Location,
              Street,
              City,
              Province,
              Postal_Code,
              Country
          FROM Service_Locations
          WHERE ((Street like '${escapedTerm}%' or City like '${escapedTerm}%') or Postal_Code like '${escapedTerm}%')
          LIMIT 30
        `;
        //  OR  
        console.log("üìã Address Search Query:", searchQuery.trim());
        const searchRes = await ZOHO.CRM.API.coql({ select_query: searchQuery });
        console.log("üì• Address Search Response:", searchRes);
        
        if (searchRes.data && searchRes.data.length > 0) {
          if (hintEl) hintEl.textContent = `${searchRes.data.length} address(es) found`;
          
          resultsEl.innerHTML = "";
          resultsEl.classList.remove("hidden");
          
          searchRes.data.forEach((loc, idx) => {
            const locRoomLocation = loc.Room_Location || "";
            const locStreet = loc.Street || "";
            const locCity = loc.City || "";
            const locProvince = loc.Province || loc.State || "";
            const locPostalCode = loc.Postal_Code || loc.Zip_Code || "";
            const locCountry = loc.Country || "";
            const locAccountId = loc.Account ? (loc.Account.id || loc.Account) : "";
            const locAccountName = loc.Account ? (loc.Account.name || "") : "";
            
            // Build display text
            const streetWithRoom = locRoomLocation ? `${locRoomLocation}, ${locStreet}` : locStreet;
            const addressText = [streetWithRoom, locCity, locProvince, locPostalCode].filter(Boolean).join(", ") || loc.Name || "Service Location";
            
            const resultItem = document.createElement("div");
            resultItem.className = "address-search-result";
            resultItem.style.cssText = "padding: 10px 12px; cursor: pointer; border-bottom: 1px solid #e2e8f0; transition: background 0.2s;";
            resultItem.innerHTML = `
              <div style="font-size: 14px; color: #1e293b; font-weight: 500;">üìç ${addressText}</div>
              ${locAccountName ? `<div style="font-size: 12px; color: #64748b; margin-top: 2px;">Account: ${locAccountName}</div>` : ""}
            `;
            
            // Hover effects
            resultItem.onmouseenter = () => resultItem.style.background = "#f0f9ff";
            resultItem.onmouseleave = () => resultItem.style.background = "white";
            
            // Click to select
            resultItem.onclick = () => selectSearchedAddress({
              id: loc.id,
              name: loc.Name || "",
              roomLocation: locRoomLocation,
              street: locStreet,
              city: locCity,
              province: locProvince,
              postalCode: locPostalCode,
              country: locCountry,
              accountId: locAccountId,
              accountName: locAccountName
            });
            
            resultsEl.appendChild(resultItem);
          });
        } else {
          if (hintEl) hintEl.textContent = "No addresses found. Try different search terms.";
          resultsEl.innerHTML = `<div style="padding: 12px; text-align: center; color: #64748b; font-size: 13px;">No results found</div>`;
          resultsEl.classList.remove("hidden");
        }
      } catch (err) {
        console.error("‚ùå Address search error:", err);
        if (hintEl) hintEl.textContent = "Error searching. Please try again.";
      }
    }
    
    // Handle selection of a searched address
    function selectSearchedAddress(addressData) {
      console.log("‚úÖ Selected address from search:", addressData);
      
      const searchContainer = document.getElementById("addressSearchContainer");
      const searchInput = document.getElementById("addressSearchInput");
      const resultsEl = document.getElementById("addressSearchResults");
      const statusEl = document.getElementById("shippingAddressStatus");
      const contactStatusEl = document.getElementById("shippingContactFieldsStatus");
      const warningEl = document.getElementById("shippingAddressUpdateWarning");
      
      // Hide search container
      if (searchContainer) searchContainer.classList.add("hidden");
      if (searchInput) searchInput.value = "";
      if (resultsEl) {
        resultsEl.innerHTML = "";
        resultsEl.classList.add("hidden");
      }
      
      // Update dropdown to show the selected address
      const addressSelect = document.getElementById("shippingAddressOption");
      
      // Create a new option for the selected address
      const addressText = [
        addressData.roomLocation ? `${addressData.roomLocation}, ${addressData.street}` : addressData.street,
        addressData.city,
        addressData.province,
        addressData.postalCode
      ].filter(Boolean).join(", ") || "Selected Address";
      
      // Remove any existing SEARCHED_ option
      const existingSearched = addressSelect.querySelector('option[value^="SEARCHED_"]');
      if (existingSearched) existingSearched.remove();
      
      // Add new option for selected address
      const newOption = document.createElement("option");
      newOption.value = `SEARCHED_${addressData.id}`;
      newOption.textContent = `üîç ${addressText} [Searched]`;
      newOption.dataset.contactData = JSON.stringify({
        id: null,
        name: "",
        email: "",
        phone: "",
        role: "Searched",
        serviceLocationId: addressData.id,
        accountId: addressData.accountId,
        accountName: addressData.accountName,
        roomLocation: addressData.roomLocation,
        street: addressData.street,
        city: addressData.city,
        province: addressData.province,
        postalCode: addressData.postalCode,
        country: addressData.country,
        source: "searched_address"
      });
      
      // Insert after SEARCH_ADDRESS option
      const searchOption = addressSelect.querySelector('option[value="SEARCH_ADDRESS"]');
      if (searchOption && searchOption.nextSibling) {
        addressSelect.insertBefore(newOption, searchOption.nextSibling);
      } else {
        addressSelect.appendChild(newOption);
      }
      
      // Select the new option
      addressSelect.value = `SEARCHED_${addressData.id}`;
      
      // Set shipping address data
      shippingSelectedContact = null;
      shippingSelectedAddress = { 
        type: "SEARCHED", 
        id: addressData.id,
        role: "Searched"
      };
      
      // Populate shipping address fields
      document.getElementById("shipRoomLocation").value = addressData.roomLocation || "";
      document.getElementById("shipStreet").value = addressData.street || "";
      document.getElementById("shipCity").value = addressData.city || "";
      document.getElementById("shipProvince").value = addressData.province || "";
      document.getElementById("shipPostal").value = formatCanadianPostal(addressData.postalCode) || "";
      document.getElementById("shipCountry").value = addressData.country || "";
      
      // Keep contact details from lead
      populateShippingContactFromLead();
      
      // Update status indicators
      if (statusEl) {
        statusEl.textContent = "Searched Address";
        statusEl.style.background = "#ddd6fe";
        statusEl.style.color = "#6d28d9";
      }
      
      if (contactStatusEl) {
        contactStatusEl.textContent = "From Lead";
        contactStatusEl.style.background = "#fef3c7";
        contactStatusEl.style.color = "#92400e";
      }
      
      // Show warning for address updates
      if (warningEl) warningEl.classList.remove("hidden");
      
      // Fetch linked Account's billing if available
      if (addressData.accountId) {
        addLinkedAccountBillingToDropdown(addressData.accountId, addressData.accountName);
      }
      
      // Sync billing if same as shipping is checked
      syncBillingWithShipping();
    }
    // ========== END ADDRESS SEARCH FUNCTIONS ==========

    // ========== BILLING ADDRESS SEARCH FUNCTIONS ==========
    let billingAddressSearchTimeout = null;

    // Debounce handler for billing address search
    function debounceBillingAddressSearch() {
      if (billingAddressSearchTimeout) {
        clearTimeout(billingAddressSearchTimeout);
      }
      
      const searchInput = document.getElementById("billingAddressSearchInput");
      const hintEl = document.getElementById("billingAddressSearchHint");
      
      if (searchInput.value.length < 3) {
        if (hintEl) hintEl.textContent = "Type at least 3 characters to search";
        const resultsEl = document.getElementById("billingAddressSearchResults");
        if (resultsEl) {
          resultsEl.innerHTML = "";
          resultsEl.classList.add("hidden");
        }
        return;
      }
      
      if (hintEl) hintEl.textContent = "Searching...";
      
      billingAddressSearchTimeout = setTimeout(() => {
        performBillingAddressSearch();
      }, 400);
    }

    // Perform billing address search against Service_Locations
    async function performBillingAddressSearch() {
      const searchInput = document.getElementById("billingAddressSearchInput");
      const resultsEl = document.getElementById("billingAddressSearchResults");
      const hintEl = document.getElementById("billingAddressSearchHint");
      
      const searchTerm = searchInput?.value?.trim() || "";
      
      if (searchTerm.length < 3) {
        if (hintEl) hintEl.textContent = "Type at least 3 characters to search";
        return;
      }
      
      console.log("üîç Searching billing addresses for:", searchTerm);
      
      try {
        const escapedTerm = searchTerm.replace(/'/g, "\\'");
        
        const searchQuery = `SELECT
              id,
              Name,
              Billing_Room_Location,
              Billing_Street,
              Billing_City,
              Billing_Province,
              Billing_Postal_Code,
              Billing_Country
          FROM Billing_Address
          WHERE ((Billing_Street like '${escapedTerm}%' or Billing_City like '${escapedTerm}%') or Billing_Postal_Code like '${escapedTerm}%')
          LIMIT 30
        `;
        
        console.log("üìã Billing Address Search Query:", searchQuery.trim());
        const searchRes = await ZOHO.CRM.API.coql({ select_query: searchQuery });
        console.log("üì• Billing Address Search Response:", searchRes);
        
        if (searchRes.data && searchRes.data.length > 0) {
          if (hintEl) hintEl.textContent = `${searchRes.data.length} address(es) found`;
          
          resultsEl.innerHTML = "";
          resultsEl.classList.remove("hidden");
          
          searchRes.data.forEach((loc, idx) => {
            // Use Billing_Address field names
            const locRoomLocation = loc.Billing_Room_Location || "";
            const locStreet = loc.Billing_Street || "";
            const locCity = loc.Billing_City || "";
            const locProvince = loc.Billing_Province || "";
            const locPostalCode = loc.Billing_Postal_Code || "";
            const locCountry = loc.Billing_Country || "";
            const locAccountId = loc.Account ? (loc.Account.id || loc.Account) : "";
            const locAccountName = loc.Account ? (loc.Account.name || "") : "";
            
            // Build address text from actual address fields (not Name which is auto-number)
            const streetWithRoom = locRoomLocation ? `${locRoomLocation}, ${locStreet}` : locStreet;
            const addressText = [streetWithRoom, locCity, locProvince, locPostalCode].filter(Boolean).join(", ") || "Billing Address";
            
            const resultItem = document.createElement("div");
            resultItem.className = "billing-address-search-result";
            resultItem.style.cssText = "padding: 10px 12px; cursor: pointer; border-bottom: 1px solid #e2e8f0; transition: background 0.2s;";
            resultItem.innerHTML = `
              <div style="font-size: 14px; color: #1e293b; font-weight: 500;">üìç ${addressText}</div>
              ${locAccountName ? `<div style="font-size: 12px; color: #64748b; margin-top: 2px;">Account: ${locAccountName}</div>` : ""}
            `;
            
            resultItem.onmouseenter = () => resultItem.style.background = "#f0f9ff";
            resultItem.onmouseleave = () => resultItem.style.background = "white";
            
            resultItem.onclick = () => selectSearchedBillingAddress({
              id: loc.id,
              name: loc.Name || "",
              roomLocation: locRoomLocation,
              street: locStreet,
              city: locCity,
              province: locProvince,
              postalCode: locPostalCode,
              country: locCountry,
              accountId: locAccountId,
              accountName: locAccountName
            });
            
            resultsEl.appendChild(resultItem);
          });
        } else {
          if (hintEl) hintEl.textContent = "No addresses found. Try different search terms.";
          resultsEl.innerHTML = `<div style="padding: 12px; text-align: center; color: #64748b; font-size: 13px;">No results found</div>`;
          resultsEl.classList.remove("hidden");
        }
      } catch (err) {
        console.error("‚ùå Billing address search error:", err);
        if (hintEl) hintEl.textContent = "Error searching. Please try again.";
      }
    }

    // Handle selection of a searched billing address
    function selectSearchedBillingAddress(addressData) {
      console.log("‚úÖ Selected billing address from search:", addressData);
      
      const searchContainer = document.getElementById("billingAddressSearchContainer");
      const searchInput = document.getElementById("billingAddressSearchInput");
      const resultsEl = document.getElementById("billingAddressSearchResults");
      const statusEl = document.getElementById("billingAddressStatus");
      const warningEl = document.getElementById("billingAddressWarning");
      
      // Hide search container
      if (searchContainer) searchContainer.classList.add("hidden");
      if (searchInput) searchInput.value = "";
      if (resultsEl) {
        resultsEl.innerHTML = "";
        resultsEl.classList.add("hidden");
      }
      
      // Update dropdown
      const billingSelect = document.getElementById("billingAddressOption");
      
      // Create address text for option
      const addressText = [
        addressData.roomLocation ? `${addressData.roomLocation}, ${addressData.street}` : addressData.street,
        addressData.city,
        addressData.province,
        addressData.postalCode
      ].filter(Boolean).join(", ") || "Selected Address";
      
      // Remove any existing SEARCHED_ option
      const existingSearched = billingSelect.querySelector('option[value^="SEARCHED_"]');
      if (existingSearched) existingSearched.remove();
      
      // Create new option for the selected address
      const newOption = document.createElement("option");
      newOption.value = `SEARCHED_${addressData.id}`;
      newOption.textContent = `üìç ${addressText}`;
      newOption.dataset.billingData = JSON.stringify({
        source: "searched_address",
        serviceLocationId: addressData.id,
        street: addressData.street,
        city: addressData.city,
        province: addressData.province,
        postalCode: addressData.postalCode,
        country: addressData.country,
        accountId: addressData.accountId,
        accountName: addressData.accountName
      });
      
      // Insert after SEARCH_ADDRESS option
      const searchAddressOpt = billingSelect.querySelector('option[value="SEARCH_ADDRESS"]');
      if (searchAddressOpt) {
        billingSelect.insertBefore(newOption, searchAddressOpt.nextSibling);
      } else {
        billingSelect.appendChild(newOption);
      }
      
      // Select the new option
      billingSelect.value = `SEARCHED_${addressData.id}`;
      
      // Set billing selection state
      selectedBillingOption = "SEARCHED";
      selectedBillingAccount = addressData.accountId || null;
      
      // Populate billing address fields
      document.getElementById("billStreet").value = addressData.street || "";
      document.getElementById("billCity").value = addressData.city || "";
      document.getElementById("billProvince").value = addressData.province || "";
      document.getElementById("billPostal").value = formatCanadianPostal(addressData.postalCode) || "";
      document.getElementById("billCountry").value = addressData.country || "";
      
      // Update status
      if (statusEl) {
        statusEl.textContent = "Searched Address";
        statusEl.style.background = "#ddd6fe";
        statusEl.style.color = "#6d28d9";
      }
      
      // Show warning
      if (warningEl) warningEl.style.display = "block";
    }
    // ========== END BILLING ADDRESS SEARCH FUNCTIONS ==========

    // Handle shipping address option change - populates contact and address based on source type
    function onShippingAddressOptionChange() {
      const addressSelect = document.getElementById("shippingAddressOption");
      const selectedOption = addressSelect.options[addressSelect.selectedIndex];
      const warningEl = document.getElementById("shippingAddressUpdateWarning");
      const contactWarningEl = document.getElementById("shippingContactUpdateWarning");
      const statusEl = document.getElementById("shippingAddressStatus");
      const contactStatusEl = document.getElementById("shippingContactFieldsStatus");
      const searchContainer = document.getElementById("addressSearchContainer");
      
      // Always keep shipping address visible and editable
      setShippingAddressFieldsEditable(true);

      // Reset warnings
      if (warningEl) warningEl.classList.add("hidden");
      if (contactWarningEl) contactWarningEl.classList.add("hidden");
      
      // Hide search container by default
      if (searchContainer) searchContainer.classList.add("hidden");

      // Always remove old linked billing option when shipping changes
      const billingSelect = document.getElementById("billingAddressOption");
      if (billingSelect) {
        const existingLinked = billingSelect.querySelector('option[value^="LINKED_"]');
        if (existingLinked) {
          console.log("üóëÔ∏è Removing old linked billing option");
          existingLinked.remove();
        }
        const oldSeparator = Array.from(billingSelect.options).find(opt => 
          opt.textContent.includes("From Shipping's Account")
        );
        if (oldSeparator) oldSeparator.remove();
      }
      
      // Handle Search Address option
      if (selectedOption && selectedOption.value === "SEARCH_ADDRESS") {
        if (searchContainer) {
          searchContainer.classList.remove("hidden");
          document.getElementById("addressSearchInput")?.focus();
        }
        // Clear search results
        const searchResults = document.getElementById("addressSearchResults");
        if (searchResults) {
          searchResults.innerHTML = "";
          searchResults.classList.add("hidden");
        }
        return;
      }

      if (!selectedOption || !selectedOption.value || selectedOption.value === "CREATE_NEW") {
        // Create new or no selection - use lead details for both contact and address
        shippingSelectedContact = null;
        shippingSelectedAddress = { type: "NEW" };
        
        populateShippingContactFromLead();
        populateShippingFromLeadDetails();
        
        if (statusEl) {
          statusEl.textContent = selectedOption?.value === "CREATE_NEW" ? "New Address" : "From Lead";
          statusEl.style.background = selectedOption?.value === "CREATE_NEW" ? "#dbeafe" : "#fef3c7";
          statusEl.style.color = selectedOption?.value === "CREATE_NEW" ? "#1d4ed8" : "#92400e";
        }
        
        if (contactStatusEl) {
          contactStatusEl.textContent = "From Lead";
          contactStatusEl.style.background = "#fef3c7";
          contactStatusEl.style.color = "#92400e";
        }
        return;
      }

      // Selected an existing address
      if (selectedOption.dataset.contactData) {
        const data = JSON.parse(selectedOption.dataset.contactData);
        const source = data.source || "contact_type";
        
        // Handle different source types
        if (source === "similar_address") {
          // Similar address - keep contact as Lead, only fill address
          shippingSelectedContact = null;
          shippingSelectedAddress = { 
            type: "SIMILAR", 
            id: data.serviceLocationId,
            role: data.role || "Same Postal Code"
          };
          
          // Keep contact details from lead
          populateShippingContactFromLead();
          
          // Update contact status to show it's still from lead
          if (contactStatusEl) {
            contactStatusEl.textContent = "From Lead";
            contactStatusEl.style.background = "#fef3c7";
            contactStatusEl.style.color = "#92400e";
          }
          
          // Populate shipping address fields from similar address
          document.getElementById("shipRoomLocation").value = data.roomLocation || "";
          document.getElementById("shipStreet").value = data.street || "";
          document.getElementById("shipCity").value = data.city || "";
          document.getElementById("shipProvince").value = data.province || "";
          document.getElementById("shipPostal").value = data.postalCode || "";
          document.getElementById("shipCountry").value = data.country || "";
          
          // Update address status
          if (statusEl) {
            statusEl.textContent = `Similar Address [${data.role || "Same Postal Code"}]`;
            statusEl.style.background = "#e0f2fe";
            statusEl.style.color = "#0369a1";
          }
          
          // Show address warning
          if (warningEl) warningEl.classList.remove("hidden");
          
          // Fetch linked Account's billing via Contact ‚Üí Account ‚Üí Billing
          // Similar addresses have accountId from Service Location, or we get it from Contact
          if (data.accountId) {
            addLinkedAccountBillingToDropdown(data.accountId, data.accountName);
          } else if (data.id) {
            // No direct accountId, fetch via Contact
            fetchAccountBillingFromContact(data.id);
          }
          
        } else if (source === "searched_address") {
          // Searched address - keep contact as Lead, only fill address
          shippingSelectedContact = null;
          shippingSelectedAddress = { 
            type: "SEARCHED", 
            id: data.serviceLocationId,
            role: "Searched"
          };
          
          // Keep contact details from lead
          populateShippingContactFromLead();
          
          // Update contact status to show it's still from lead
          if (contactStatusEl) {
            contactStatusEl.textContent = "From Lead";
            contactStatusEl.style.background = "#fef3c7";
            contactStatusEl.style.color = "#92400e";
          }
          
          // Populate shipping address fields from searched address
          document.getElementById("shipRoomLocation").value = data.roomLocation || "";
          document.getElementById("shipStreet").value = data.street || "";
          document.getElementById("shipCity").value = data.city || "";
          document.getElementById("shipProvince").value = data.province || "";
          document.getElementById("shipPostal").value = formatCanadianPostal(data.postalCode) || "";
          document.getElementById("shipCountry").value = data.country || "";
          
          // Update address status
          if (statusEl) {
            statusEl.textContent = "Searched Address";
            statusEl.style.background = "#ddd6fe";
            statusEl.style.color = "#6d28d9";
          }
          
          // Show address warning
          if (warningEl) warningEl.classList.remove("hidden");
          
          // Fetch linked Account's billing if available
          if (data.accountId) {
            addLinkedAccountBillingToDropdown(data.accountId, data.accountName);
          }
          
        } else {
          // Contact-based address (contact_email_phone, contact_service_location, contact_type)
          shippingSelectedContact = data.id ? { id: data.id } : null;
          shippingSelectedAddress = { 
            type: "EXISTING", 
            id: selectedOption.value,
            serviceLocationId: data.serviceLocationId || null,
            role: data.role || ""
          };
          
          // Populate contact details from selected contact
          document.getElementById("shippingContactName").value = data.name || "";
          document.getElementById("shippingContactEmail").value = data.email || "";
          document.getElementById("shippingContactPhone").value = formatPhoneDisplay(data.phone) || "";
          
          // Update contact status based on source
          if (contactStatusEl) {
            if (source === "contact_email_phone") {
              contactStatusEl.textContent = `Linked Contact [${data.role || "Contact"}]`;
              contactStatusEl.style.background = "#dcfce7";
              contactStatusEl.style.color = "#166534";
            } else if (source === "contact_service_location") {
              contactStatusEl.textContent = `From Deal [${data.role || "Contact"}]`;
              contactStatusEl.style.background = "#dcfce7";
              contactStatusEl.style.color = "#166534";
            } else {
              contactStatusEl.textContent = `Existing [${data.role || "Contact"}]`;
              contactStatusEl.style.background = "#dcfce7";
              contactStatusEl.style.color = "#166534";
            }
          }
          
          // Show contact warning for existing contact
          if (data.id && contactWarningEl) {
            contactWarningEl.classList.remove("hidden");
          }
          
          // Populate shipping address fields
          document.getElementById("shipRoomLocation").value = data.roomLocation || "";
          document.getElementById("shipStreet").value = data.street || "";
          document.getElementById("shipCity").value = data.city || "";
          document.getElementById("shipProvince").value = data.province || "";
          document.getElementById("shipPostal").value = data.postalCode || "";
          document.getElementById("shipCountry").value = data.country || "";
          
          // Update address status
          if (statusEl) {
            if (source === "contact_service_location") {
              statusEl.textContent = `Service Location [${data.role || "Contact"}]`;
        } else {
              statusEl.textContent = `Existing [${data.role || "Contact"}]`;
            }
            statusEl.style.background = "#dcfce7";
            statusEl.style.color = "#166534";
          }
          
          // Show address warning for existing
          if (warningEl) warningEl.classList.remove("hidden");
          
          // Fetch linked Account's billing via Contact ‚Üí Account ‚Üí Billing
          if (data.accountId) {
            addLinkedAccountBillingToDropdown(data.accountId, data.accountName);
          } else if (data.id) {
            // No direct accountId, fetch via Contact
            fetchAccountBillingFromContact(data.id);
          }
        }
      }
      
      // Sync billing with shipping if checkbox is checked
      syncBillingWithShipping();
    }

    // Note: Old contact type functions removed - shipping now uses address selection from contacts directly

    function onShippingExistingAddressChange() {
      const addressSelect = document.getElementById("shippingExistingAddressSelect");
      const selectedOption = addressSelect.options[addressSelect.selectedIndex];
      
      if (!selectedOption || !selectedOption.value) {
        shippingSelectedAddress = null;
        clearShippingAddressFields();
        const addressWarning = document.getElementById("shippingAddressUpdateWarning");
        if (addressWarning) addressWarning.classList.add("hidden");
        return;
      }

      if (selectedOption.value === "BILLING_ADDRESS") {
        // Use billing account address - populate from cached account data
        shippingSelectedAddress = { type: "BILLING" };
        
        if (cachedAccountData) {
          shipStreet.value = cachedAccountData.Billing_Street || "";
          shipCity.value = cachedAccountData.Billing_City || "";
          shipProvince.value = cachedAccountData.Billing_State || "";
          shipPostal.value = formatCanadianPostal(cachedAccountData.Billing_Code) || "";
          shipCountry.value = cachedAccountData.Billing_Country || "";
        }
        
        // Show warning and keep fields editable
        setShippingAddressFieldsEditable(true);
        const addressWarning = document.getElementById("shippingAddressUpdateWarning");
        if (addressWarning) addressWarning.classList.remove("hidden");
        
      } else if (selectedOption.dataset.addressData) {
        const addressData = JSON.parse(selectedOption.dataset.addressData);
        shippingSelectedAddress = addressData;
        
        // Populate address fields from selected service location using individual fields
          shipStreet.value = addressData.Street || "";
          shipCity.value = addressData.City || "";
          shipProvince.value = addressData.State || addressData.Province || "";
          shipPostal.value = formatCanadianPostal(addressData.Zip_Code || addressData.Postal_Code) || "";
          shipCountry.value = addressData.Country || "";
        
        // Show warning and keep fields editable
        setShippingAddressFieldsEditable(true);
        const addressWarning = document.getElementById("shippingAddressUpdateWarning");
        if (addressWarning) addressWarning.classList.remove("hidden");
      }
    }

    // Helper function to parse address string into components
    // Expected format: "Street, City, Province, Country, Postal Code"
    function parseAddressString(addressString) {
      const result = {
        street: "",
        city: "",
        province: "",
        country: "",
        postalCode: ""
      };
      
      if (!addressString) return result;
      
      // Split by comma
      const parts = addressString.split(",").map(part => part.trim());
      
      if (parts.length >= 1) result.street = parts[0];
      if (parts.length >= 2) result.city = parts[1];
      if (parts.length >= 3) result.province = parts[2];
      if (parts.length >= 4) result.country = parts[3];
      if (parts.length >= 5) result.postalCode = parts[4];
      
      // If only 4 parts, the last part might be postal code (if it looks like one)
      if (parts.length === 4) {
        const lastPart = parts[3];
        // Check if last part looks like a postal code (contains numbers)
        if (/\d/.test(lastPart) && lastPart.length <= 10) {
          result.postalCode = lastPart;
          result.country = "";
        }
      }
      
      return result;
    }

    function setShippingContactFieldsEditable(editable) {
      document.getElementById("shippingContactName").disabled = !editable;
      document.getElementById("shippingContactEmail").disabled = !editable;
      document.getElementById("shippingContactPhone").disabled = !editable;

      const statusEl = document.getElementById("shippingContactFieldsStatus");
      if (statusEl) {
        if (editable) {
          statusEl.textContent = "Editable";
          statusEl.style.background = "#dcfce7";
          statusEl.style.color = "#166534";
        } else {
          statusEl.textContent = "Read-only";
          statusEl.style.background = "#e2e8f0";
          statusEl.style.color = "#64748b";
        }
      }
    }

    function setShippingAddressFieldsEditable(editable) {
      shipStreet.disabled = !editable;
      shipCity.disabled = !editable;
      shipProvince.disabled = !editable;
      shipPostal.disabled = !editable;
      shipCountry.disabled = !editable;

      const statusEl = document.getElementById("shippingAddressStatus");
      if (statusEl) {
        if (editable) {
          statusEl.textContent = "Editable";
          statusEl.style.background = "#dcfce7";
          statusEl.style.color = "#166534";
        } else {
          statusEl.textContent = "Read-only";
          statusEl.style.background = "#e2e8f0";
          statusEl.style.color = "#64748b";
        }
      }
    }

    function clearShippingContactFields() {
      document.getElementById("shippingContactName").value = "";
      document.getElementById("shippingContactEmail").value = "";
      document.getElementById("shippingContactPhone").value = "";
      shippingSelectedContact = null;
      
      // Hide warning
      const warningBox = document.getElementById("shippingContactUpdateWarning");
      if (warningBox) warningBox.classList.add("hidden");
    }

    // Populate shipping contact fields from lead details
    function populateShippingContactFromLead() {
      document.getElementById("shippingContactName").value = initialLeadDetails.name || "";
      document.getElementById("shippingContactEmail").value = initialLeadDetails.email || "";
      document.getElementById("shippingContactPhone").value = formatPhoneDisplay(initialLeadDetails.phone) || "";
      shippingSelectedContact = null;
      
      // Hide warning (creating new contact)
      const warningBox = document.getElementById("shippingContactUpdateWarning");
      if (warningBox) warningBox.classList.add("hidden");
      
      // Update status badge
      const statusEl = document.getElementById("shippingContactFieldsStatus");
      if (statusEl) {
        statusEl.textContent = "From Lead";
        statusEl.style.background = "#fef3c7";
        statusEl.style.color = "#92400e";
      }
    }

    function clearShippingAddressFields() {
      shipStreet.value = "";
      shipCity.value = "";
      shipProvince.value = "";
      shipPostal.value = "";
      shipCountry.value = "";
      shippingSelectedAddress = null;
    }

    /* ========== END SHIPPING ADDRESS SECTION FUNCTIONS ========== */

    function shouldShowBillingUsage() {
      if (!belongsValue) return false;

      const allowed = BILLING_USAGE_RULES[belongsValue] || [];
      return allowed.length > 0;
    }


    function clearManualBillingFields() {
      ["billStreet", "billCity", "billProvince", "billPostal", "billCountry"]
        .forEach(id => {
          const el = document.getElementById(id);
          if (el) el.value = "";
        });
    }

    // Populate billing address fields from lead details
    function populateBillingFromLeadDetails() {
      billStreet.value = initialLeadDetails.billStreet || "";
      billCity.value = initialLeadDetails.billCity || "";
      billProvince.value = initialLeadDetails.billProvince || "";
      billPostal.value = formatCanadianPostal(initialLeadDetails.billPostal) || "";
      billCountry.value = initialLeadDetails.billCountry || "";
    }

    // Populate shipping address fields from lead details
    function populateShippingFromLeadDetails() {
      shipRoomLocation.value = initialLeadDetails.shipRoomLocation || "";
      shipStreet.value = initialLeadDetails.shipStreet || "";
      shipCity.value = initialLeadDetails.shipCity || "";
      shipProvince.value = initialLeadDetails.shipProvince || "";
      shipPostal.value = formatCanadianPostal(initialLeadDetails.shipPostal) || "";
      shipCountry.value = initialLeadDetails.shipCountry || "";
      
      // Update status badge
      const statusEl = document.getElementById("shippingAddressStatus");
      if (statusEl) {
        statusEl.textContent = "From Lead";
        statusEl.style.background = "#fef3c7";
        statusEl.style.color = "#92400e";
      }
    }

    // Reset Shipping Address to Lead Details
    function resetShippingAddress() {
      // Reset shipping address dropdown to "Create New"
      const shippingSelect = document.getElementById("shippingAddressOption");
      if (shippingSelect) {
        shippingSelect.value = "CREATE_NEW";
      }
      
      // Reset shipping address fields to lead details
      shipRoomLocation.value = initialLeadDetails.shipRoomLocation || "";
      shipStreet.value = initialLeadDetails.shipStreet || "";
      shipCity.value = initialLeadDetails.shipCity || "";
      shipProvince.value = initialLeadDetails.shipProvince || "";
      shipPostal.value = formatCanadianPostal(initialLeadDetails.shipPostal) || "";
      shipCountry.value = initialLeadDetails.shipCountry || "";
      
      // Reset contact details to lead details (use correct property names: name, email, phone)
      const shippingContactName = document.getElementById("shippingContactName");
      const shippingContactEmail = document.getElementById("shippingContactEmail");
      const shippingContactPhone = document.getElementById("shippingContactPhone");
      
      if (shippingContactName) {
        shippingContactName.value = initialLeadDetails.name || "";
      }
      if (shippingContactEmail) {
        shippingContactEmail.value = initialLeadDetails.email || "";
      }
      if (shippingContactPhone) {
        shippingContactPhone.value = formatPhoneDisplay(initialLeadDetails.phone) || "";
      }
      
      // Clear selected address/contact state
      shippingSelectedAddress = null;
      shippingSelectedContact = null;
      
      // Update status badges
      const addressStatusEl = document.getElementById("shippingAddressStatus");
      if (addressStatusEl) {
        addressStatusEl.textContent = "From Lead";
        addressStatusEl.style.background = "#fef3c7";
        addressStatusEl.style.color = "#92400e";
      }
      
      const contactStatusEl = document.getElementById("shippingContactStatus");
      if (contactStatusEl) {
        contactStatusEl.textContent = "From Lead";
        contactStatusEl.style.background = "#fef3c7";
        contactStatusEl.style.color = "#92400e";
      }
      
      console.log("Shipping address reset to lead details");
    }

    // Handle "Billing same as Shipping" checkbox change
    function onBillingSameAsShippingChange() {
      const checkbox = document.getElementById("billingSameAsShipping");
      const billingSection = document.getElementById("billingAddressSection");
      
      // Get all BILLING checkboxes (there are 2 role dropdowns)
      const billingRoleCheckboxes = document.querySelectorAll('input[type="checkbox"][value="BILLING"]');
      
      if (checkbox && checkbox.checked) {
        // CHECKED: Select BILLING and disable it (can't deselect)
        billingRoleCheckboxes.forEach(cb => {
          cb.checked = true;
          cb.disabled = true;
          cb.parentElement.style.opacity = '0.7';
          cb.parentElement.style.display = ''; // Show it
          cb.parentElement.title = 'Required when billing same as shipping';
        });
        // Update the roles display
        updateRoles();
        
        // Hide billing address section
        if (billingSection) {
          billingSection.style.display = 'none';
        }
        
        // Copy shipping contact details to billing account details
        const shippingContactName = document.getElementById("shippingContactName");
        const shippingContactEmail = document.getElementById("shippingContactEmail");
        const shippingContactPhone = document.getElementById("shippingContactPhone");
        
        const accountName = document.getElementById("accountName");
        const accountPhone = document.getElementById("accountPhone");
        const accountEmail = document.getElementById("accountEmail");
        
        if (accountName && shippingContactName) {
          accountName.value = shippingContactName.value;
        }
        if (accountPhone && shippingContactPhone) {
          accountPhone.value = shippingContactPhone.value;
        }
        if (accountEmail && shippingContactEmail) {
          accountEmail.value = shippingContactEmail.value;
        }
        
        // Copy shipping address to billing address
        if (billStreet && shipStreet) billStreet.value = shipStreet.value;
        if (billCity && shipCity) billCity.value = shipCity.value;
        if (billProvince && shipProvince) billProvince.value = shipProvince.value;
        if (billPostal && shipPostal) billPostal.value = shipPostal.value;
        if (billCountry && shipCountry) billCountry.value = shipCountry.value;
        
        console.log("Billing set same as shipping - BILLING role locked");
      } else {
        // UNCHECKED: Hide BILLING option completely
        billingRoleCheckboxes.forEach(cb => {
          cb.checked = false;
          cb.disabled = false;
          cb.parentElement.style.display = 'none'; // Hide the label
          cb.parentElement.style.opacity = '1';
          cb.parentElement.title = '';
        });
        // Update the roles display
        updateRoles();
        
        // Show billing address section
        if (billingSection) {
          billingSection.style.display = 'block';
        }
        
        // Reset billing to lead details when unchecked
        resetBillingAddress();
        
        console.log("Billing section shown - BILLING role hidden");
      }
    }
    
    // Initialize BILLING role visibility on page load
    function initBillingRoleVisibility() {
      const checkbox = document.getElementById("billingSameAsShipping");
      const billingRoleCheckboxes = document.querySelectorAll('input[type="checkbox"][value="BILLING"]');
      
      // If checkbox is unchecked on load, hide BILLING option
      if (!checkbox || !checkbox.checked) {
        billingRoleCheckboxes.forEach(cb => {
          cb.parentElement.style.display = 'none';
        });
      }
      
      // Also hide the "Billing same as shipping" checkbox until a parent position is selected
      const billingSameCheckboxContainer = checkbox?.parentElement?.parentElement;
      const shippingBelongsTo = document.getElementById("shippingBelongsTo")?.value;
      if (billingSameCheckboxContainer && (!shippingBelongsTo || !isParentPosition(shippingBelongsTo))) {
        billingSameCheckboxContainer.style.display = 'none';
      }
    }
    
    // Sync billing with shipping when checkbox is checked and shipping changes
    function syncBillingWithShipping() {
      const checkbox = document.getElementById("billingSameAsShipping");
      if (checkbox && checkbox.checked) {
        onBillingSameAsShippingChange();
      }
    }

    // Reset Billing Address to Lead Details
    function resetBillingAddress() {
      // Reset billing address dropdown to "Create New"
      const billingSelect = document.getElementById("billingAddressOption");
      if (billingSelect) {
        billingSelect.value = "CREATE_NEW";
      }
      
      // Reset billing address fields to lead details
      if (billStreet) billStreet.value = initialLeadDetails.billStreet || "";
      if (billCity) billCity.value = initialLeadDetails.billCity || "";
      if (billProvince) billProvince.value = initialLeadDetails.billProvince || "";
      if (billPostal) billPostal.value = formatCanadianPostal(initialLeadDetails.billPostal) || "";
      if (billCountry) billCountry.value = initialLeadDetails.billCountry || "";
      
      // Reset account details to lead details
      const accountNameEl = document.getElementById("accountName");
      const accountPhoneEl = document.getElementById("accountPhone");
      const accountEmailEl = document.getElementById("accountEmail");
      
      if (accountNameEl) {
        accountNameEl.value = initialLeadDetails.name || "";
      }
      if (accountPhoneEl) {
        accountPhoneEl.value = formatPhoneDisplay(initialLeadDetails.phone) || "";
      }
      if (accountEmailEl) {
        accountEmailEl.value = initialLeadDetails.email || "";
      }
      
      // Clear selected billing state
      selectedBillingAccount = null;
      selectedBillingOption = null;
      
      // Update status badge
      const statusBadge = document.getElementById("billingAddressStatus");
      if (statusBadge) {
        statusBadge.textContent = "From Lead";
        statusBadge.style.background = "#fef3c7";
        statusBadge.style.color = "#92400e";
      }
      
      console.log("Billing address reset to lead details");
    }

    // ===================== BILLING ADDRESS FUNCTIONS =====================

    // Populate billing addresses from Accounts (similar to shipping postal code or lead's billing postal code)
    async function populateBillingAddressesFromAccounts(overridePostal = null) {
      const billingSelect = document.getElementById("billingAddressOption");
      const hintEl = document.getElementById("billingAddressOptionHint");
      
      // Keep base options
      billingSelect.innerHTML = `
        <option value="">Select</option>
        <option value="CREATE_NEW">+ Create New Billing Address</option>
        <option value="SAME_AS_SHIPPING">Same as Shipping Address</option>
        <option value="SEARCH_ADDRESS">üîç Search Address</option>
      `;
      
      // Use override postal code (from shipping address) if provided, otherwise use lead's billing postal code
      const searchPostal = overridePostal || initialLeadDetails.billPostal || "";
      const leadBillingStreet = initialLeadDetails.billStreet || "";
      const streetWords = leadBillingStreet.split(/[\s,]+/).filter(word => word.length > 2);
      
      console.log("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ");
      console.log("üí∞ BILLING: Finding Similar Billing Addresses by Postal Code");
      console.log("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ");
      console.log("Search Postal Code:", searchPostal || "(empty)", overridePostal ? "(from shipping)" : "(from lead)");
      console.log("Lead Billing Street:", leadBillingStreet || "(empty)");
      
      let totalCount = 0;
      
      if (searchPostal && searchPostal.trim()) {
        try {
          // Query Accounts with same billing postal code
          const billingQuery = `
            SELECT id, Account_Name, Billing_Street, Billing_City, Billing_State, Billing_Code, Billing_Country, Phone, Email
            FROM Accounts
            WHERE Billing_Code = '${searchPostal.trim()}'
            LIMIT 30
          `;
          
          console.log("üìã Billing Query:", billingQuery.trim());
          const billingRes = await ZOHO.CRM.API.coql({ select_query: billingQuery });
          console.log("üì• Billing Query Response:", billingRes);
          
          if (billingRes.data && billingRes.data.length > 0) {
            console.log(`‚úÖ Found ${billingRes.data.length} Account(s) with billing postal code ${searchPostal}`);
            
            // Track added accounts to avoid duplicates
            const addedAccountIds = new Set();
            const uniqueAccounts = [];
            
            // Filter unique accounts
            billingRes.data.forEach((account) => {
              if (account.id && !addedAccountIds.has(account.id)) {
                addedAccountIds.add(account.id);
                uniqueAccounts.push(account);
              }
            });
            
            console.log(`   Unique accounts after deduplication: ${uniqueAccounts.length}`);
            
            if (uniqueAccounts.length > 0) {
              // Add separator
              const separator = document.createElement("option");
              separator.disabled = true;
              separator.textContent = `‚îÄ‚îÄ Similar Billing Addresses (${searchPostal}) ‚îÄ‚îÄ`;
              billingSelect.appendChild(separator);
              
              uniqueAccounts.forEach((account, idx) => {
                const accountName = account.Account_Name || "Unknown Account";
                const billingStreet = account.Billing_Street || "";
                const billingCity = account.Billing_City || "";
                const billingState = account.Billing_State || "";
                const billingPostal = account.Billing_Code || "";
                const billingCountry = account.Billing_Country || "";
                
                // Build address text
                const addressText = [billingStreet, billingCity, billingState, billingPostal].filter(Boolean).join(", ") || "No billing address";
                
                // Check similarity
                const streetLower = billingStreet.toLowerCase();
                const hasStreetMatch = streetWords.some(word => streetLower.includes(word.toLowerCase()));
                const matchLabel = hasStreetMatch ? "Similar Street" : "Same Postal Code";
                
                console.log(`   üí∞ #${idx + 1}: ${addressText} - ${accountName} [${matchLabel}]`);
                
                const option = document.createElement("option");
                option.value = `ACCOUNT_${account.id}`;
                option.textContent = `üí∞ ${addressText} - ${accountName} [${matchLabel}]`;
                option.dataset.billingData = JSON.stringify({
                  accountId: account.id,
                  accountName: accountName,
                  accountPhone: account.Phone || "",
                  accountEmail: account.Email || "",
                  street: billingStreet,
                  city: billingCity,
                  province: billingState,
                  postalCode: billingPostal,
                  country: billingCountry,
                  source: "similar_billing"
                });
                billingSelect.appendChild(option);
                totalCount++;
              });
            }
            
            console.log(`\n‚úÖ BILLING RESULT: Added ${totalCount} unique billing address(es)`);
          } else {
            console.log(`‚ö†Ô∏è No Accounts found with billing postal code: ${searchPostal}`);
          }
        } catch (err) {
          console.error("‚ùå Error fetching billing addresses:", err);
        }
      } else {
        console.log("‚ö†Ô∏è Skipping billing search - No city to search");
      }
      
      if (hintEl) {
        hintEl.textContent = totalCount > 0 
          ? `${totalCount} similar billing address(es) found`
          : "Select billing address or create new";
      }
      
      console.log("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n");
    }

    // Fetch Account billing from Contact ID (Contact ‚Üí Account ‚Üí Billing)
    async function fetchAccountBillingFromContact(contactId) {
      if (!contactId) {
        console.log("‚ö†Ô∏è No contact ID provided for billing lookup");
        return;
      }
      
      console.log("üîó Fetching Account from Contact ID:", contactId);
      
      try {
        // Fetch Contact to get linked Account
        const contactRes = await ZOHO.CRM.API.getRecord({
          Entity: "Contacts",
          RecordID: contactId
        });
        
        if (contactRes.data && contactRes.data.length > 0) {
          const contact = contactRes.data[0];
          console.log("üìá Contact data:", contact);
          
          // Get Account from Contact (Account_Name is lookup field)
          const accountLookup = contact.Account_Name;
          
          if (accountLookup && accountLookup.id) {
            const accountId = accountLookup.id;
            const accountName = accountLookup.name || "";
            
            console.log("‚úÖ Found linked Account:", accountId, accountName);
            
            // Fetch Account's billing address
            await addLinkedAccountBillingToDropdown(accountId, accountName);
          } else {
            console.log("‚ö†Ô∏è Contact has no linked Account (Account_Name field is empty)");
          }
        } else {
          console.log("‚ö†Ô∏è Contact not found:", contactId);
        }
      } catch (err) {
        console.error("‚ùå Error fetching Contact for Account billing:", err);
      }
    }

    // Add linked account billing to dropdown (called when shipping address is selected)
    async function addLinkedAccountBillingToDropdown(accountId, accountName) {
      if (!accountId) return;
      
      const billingSelect = document.getElementById("billingAddressOption");
      
      console.log("üí∞ Fetching linked Account billing:", accountId, accountName);
      
      try {
        const accountRes = await ZOHO.CRM.API.getRecord({
          Entity: "Accounts",
          RecordID: accountId
        });
        
        if (accountRes.data && accountRes.data.length > 0) {
          const account = accountRes.data[0];
          const billingStreet = account.Billing_Street || "";
          const billingCity = account.Billing_City || "";
          const billingState = account.Billing_State || "";
          const billingPostal = account.Billing_Code || "";
          const billingCountry = account.Billing_Country || "";
          
          // Check if billing address exists
          if (billingStreet || billingCity) {
            const addressText = [billingStreet, billingCity, billingState, billingPostal].filter(Boolean).join(", ");
            
            // Check if linked option already exists
            const existingLinked = billingSelect.querySelector('option[value^="LINKED_"]');
            if (existingLinked) {
              existingLinked.remove();
            }
            
            // Remove old separator if exists
            const oldSeparator = Array.from(billingSelect.options).find(opt => 
              opt.textContent.includes("From Shipping's Account")
            );
            if (oldSeparator) oldSeparator.remove();
            
            // Add separator for linked account
            const separator = document.createElement("option");
            separator.disabled = true;
            separator.textContent = `‚îÄ‚îÄ From Shipping's Account ‚îÄ‚îÄ`;
            
            // Insert after "Same as Shipping" option
            const sameAsShippingOption = billingSelect.querySelector('option[value="SAME_AS_SHIPPING"]');
            if (sameAsShippingOption && sameAsShippingOption.nextSibling) {
              billingSelect.insertBefore(separator, sameAsShippingOption.nextSibling);
            } else {
              billingSelect.appendChild(separator);
            }
            
            // Add linked account option
            const option = document.createElement("option");
            option.value = `LINKED_${account.id}`;
            option.textContent = `üîó ${addressText} - ${accountName || account.Account_Name} [Linked Account]`;
            option.dataset.billingData = JSON.stringify({
              accountId: account.id,
              accountName: accountName || account.Account_Name || "",
              accountPhone: account.Phone || "",
              accountEmail: account.Email || "",
              street: billingStreet,
              city: billingCity,
              province: billingState,
              postalCode: billingPostal,
              country: billingCountry,
              source: "linked_account"
            });
            
            // Insert after separator
            billingSelect.insertBefore(option, separator.nextSibling);
            
            // Auto-select the linked account billing
            billingSelect.value = `LINKED_${account.id}`;
            onBillingAddressOptionChange();
            
            console.log("‚úÖ Added linked Account billing:", addressText);
          } else {
            console.log("‚ö†Ô∏è Linked Account has no billing address");
          }
        }
      } catch (err) {
        console.error("‚ùå Error fetching linked account:", err);
      }
    }

    // Handle billing address option change
    function onBillingAddressOptionChange() {
      const billingSelect = document.getElementById("billingAddressOption");
      const selectedOption = billingSelect.options[billingSelect.selectedIndex];
      const statusEl = document.getElementById("billingAddressStatus");
      const warningEl = document.getElementById("billingAddressWarning");
      const billingFieldsEl = document.getElementById("manualBillingFields");
      
      // Always show billing address fields when dropdown is used
      if (billingFieldsEl) {
        billingFieldsEl.classList.remove("hidden");
      }
      
      // Hide billing search container by default
      const billingSearchContainer = document.getElementById("billingAddressSearchContainer");
      if (billingSearchContainer) billingSearchContainer.classList.add("hidden");

      // Handle Search Address option
      if (selectedOption && selectedOption.value === "SEARCH_ADDRESS") {
        if (billingSearchContainer) {
          billingSearchContainer.classList.remove("hidden");
          document.getElementById("billingAddressSearchInput")?.focus();
        }
        // Clear search results
        const searchResults = document.getElementById("billingAddressSearchResults");
        if (searchResults) {
          searchResults.innerHTML = "";
          searchResults.classList.add("hidden");
        }
        return;
      }
      
      if (!selectedOption || !selectedOption.value) {
        // No selection - use lead billing
        selectedBillingOption = null;
        populateBillingFromLead();
        if (statusEl) {
          statusEl.textContent = "From Lead";
          statusEl.style.background = "#fef3c7";
          statusEl.style.color = "#92400e";
        }
        return;
      }
      
      if (selectedOption.value === "CREATE_NEW") {
        // Create new - populate from lead details
        selectedBillingOption = "DIFFERENT";
        
        // Populate billing address from lead details
        billStreet.value = initialLeadDetails.billStreet || "";
        billCity.value = initialLeadDetails.billCity || "";
        billProvince.value = initialLeadDetails.billProvince || "";
        billPostal.value = formatCanadianPostal(initialLeadDetails.billPostal) || "";
        billCountry.value = initialLeadDetails.billCountry || "";
        
        // Populate account details from lead details
        const accountNameEl = document.getElementById("accountName");
        const accountPhoneEl = document.getElementById("accountPhone");
        const accountEmailEl = document.getElementById("accountEmail");
        
        if (accountNameEl) accountNameEl.value = initialLeadDetails.company || initialLeadDetails.name || "";
        if (accountPhoneEl) accountPhoneEl.value = formatPhoneDisplay(initialLeadDetails.phone) || "";
        if (accountEmailEl) accountEmailEl.value = initialLeadDetails.email || "";
        
        if (statusEl) {
          statusEl.textContent = "New Address";
          statusEl.style.background = "#dbeafe";
          statusEl.style.color = "#1d4ed8";
        }
        if (warningEl) warningEl.style.display = "none";
        return;
      }
      
      if (selectedOption.value === "SAME_AS_SHIPPING") {
        // Copy from shipping
        selectedBillingOption = "SAME";
        billStreet.value = shipStreet.value || "";
        billCity.value = shipCity.value || "";
        billProvince.value = shipProvince.value || "";
        billPostal.value = shipPostal.value || "";
        billCountry.value = shipCountry.value || "";
        if (statusEl) {
          statusEl.textContent = "Same as Shipping";
          statusEl.style.background = "#f3e8ff";
          statusEl.style.color = "#7c3aed";
        }
        if (warningEl) warningEl.style.display = "none";
        return;
      }
      
      // Selected an existing account billing
      if (selectedOption.dataset.billingData) {
        const data = JSON.parse(selectedOption.dataset.billingData);
        
        // Set billing option for validation (uses existing account)
        selectedBillingOption = "SAME";
        selectedBillingAccount = data.accountId || null;
        
        // Populate billing fields
        billStreet.value = data.street || "";
        billCity.value = data.city || "";
        billProvince.value = data.province || "";
        billPostal.value = formatCanadianPostal(data.postalCode) || "";
        billCountry.value = data.country || "";
        
        // Populate account details
        const accountNameEl = document.getElementById("accountName");
        const accountPhoneEl = document.getElementById("accountPhone");
        const accountEmailEl = document.getElementById("accountEmail");
        
        if (accountNameEl) accountNameEl.value = data.accountName || "";
        if (accountPhoneEl) accountPhoneEl.value = formatPhoneDisplay(data.accountPhone) || "";
        if (accountEmailEl) accountEmailEl.value = data.accountEmail || "";
        
        // Update status
        if (statusEl) {
          const label = data.source === "linked_account" ? "Linked Account" : "From Account";
          statusEl.textContent = label;
          statusEl.style.background = "#dcfce7";
          statusEl.style.color = "#166534";
        }
        
        if (warningEl) warningEl.style.display = "block";
        
        console.log("üí∞ Billing populated from:", data);
      }
    }

    // Populate billing from lead details
    function populateBillingFromLead() {
      billStreet.value = initialLeadDetails.billStreet || "";
      billCity.value = initialLeadDetails.billCity || "";
      billProvince.value = initialLeadDetails.billProvince || "";
      billPostal.value = formatCanadianPostal(initialLeadDetails.billPostal) || "";
      billCountry.value = initialLeadDetails.billCountry || "";
    }

    // ===================== END BILLING ADDRESS FUNCTIONS =====================

    function clearAccountDetailsFields() {
      ["accountName", "accountPhone", "accountEmail"]
        .forEach(id => {
          const el = document.getElementById(id);
          if (el) el.value = "";
        });
    }


    function showBillingOptions() {
      // DISABLED: Old billing options hidden - using new billingAddressOption dropdown
      // if (!belongsValue) return;
      // document.getElementById("billingOptions").classList.remove("hidden");
      // const box = document.getElementById("billingOptions");
      // box.classList.remove("hidden");
      // document.querySelectorAll('input[name="billingOption"]').forEach(r => r.checked = false);
      // selectedBillingOption = null;
      return; // Function disabled
    }

    function selectBillingOption(option) {
      selectedBillingOption = option;
      // highlightRadioGroup("billingOption", option);

      // UI highlight
      document
        .querySelectorAll('#billingOptions .billing-option')
        .forEach(opt => opt.classList.remove("selected"));

      const radio = document.querySelector(
        `input[name="billingOption"][value="${option}"]`
      );
      if (radio) {
        radio.closest(".billing-option").classList.add("selected");
      }

      // Hide dependent UI (but keep accountDetailsFields visible)
      document.getElementById("billingSearchBox").classList.add("hidden");
      document.getElementById("manualBillingFields").classList.add("hidden");
      document.getElementById("billingContactSection").classList.add("hidden");
      document.getElementById("newLandlordDetails").classList.add("hidden");
      document.getElementById("billingAccountUsageBox").classList.add("hidden");
      // document.getElementById("results").innerHTML = "";

      clearManualBillingFields();
      clearAccountDetailsFields();  // Clear but keep visible
      resetContactSelect();

      // ‚ö†Ô∏è DO NOT RESET selectedBillingAccount / selectedBookingAccount here

      if (option === "SAME") {
        // Show billing fields (will be populated and editable when account is selected)
        document.getElementById("manualBillingFields").classList.remove("hidden");
        enableManualBillingEntry();

        // Check if shipping address has an Account linked (from Service Location)
        if (shippingSelectedAddress && shippingSelectedAddress.accountId) {
          // Fetch the linked account directly
          document.getElementById("results").innerHTML = "Loading linked account...";
          fetchAccountById(shippingSelectedAddress.accountId).then(account => {
            if (account) {
              renderAccounts([account]);
            } else {
              // Fallback to address search if account not found
              if (shipStreet.value.trim()) {
                document.getElementById("results").innerHTML = "Searching related accounts...";
                searchAccountsByAddress(shipStreet.value.trim()).then(renderAccounts);
              } else {
                document.getElementById("results").innerHTML = "<p style='color:#64748b;'>No linked account found.</p>";
              }
            }
          });
        } else if (shipStreet.value.trim()) {
          // Fallback: Search by address text
          document.getElementById("results").innerHTML = "Searching related accounts...";
          searchAccountsByAddress(shipStreet.value.trim()).then(renderAccounts);
        } else {
          document.getElementById("results").innerHTML = "<p style='color:#64748b;'>Enter shipping address to see parent accounts.</p>";
        }
        
        // For LANDLORD: Reset contact mode - will be controlled when account is selected
        if (belongsValue === "LANDLORD") {
          // Re-enable all contact options first (will be adjusted when account is selected)
          resetAllContactModeOptions();
          
          // Hide related contacts until account is selected
          const relatedBox = document.getElementById("accountRelatedContactsBox");
          if (relatedBox) {
            relatedBox.classList.add("hidden");
          }
        }
      }

      if (option === "DIFFERENT") {
        // Populate billing fields from lead details when creating new account
        populateBillingFromLeadDetails();
        enableManualBillingEntry();
        document.getElementById("manualBillingFields").classList.remove("hidden");
        document.getElementById("results").innerHTML = ""; // Clear for manual
        
        // Populate account details from lead (creating new account)
        populateAccountDetailsFromLead();
        
        // Show contact section for new contact creation
        document.getElementById("billingContactSection").classList.remove("hidden");
        resetContactSelect();
        
        if (belongsValue === "TENANT") {
             document.getElementById("newLandlordDetails").classList.remove("hidden");
        }
      }

      if (option === "SEARCH") {
        // Show billing fields (will be populated and editable when account is selected)
        document.getElementById("manualBillingFields").classList.remove("hidden");
        enableManualBillingEntry();
        document.getElementById("billingSearchBox").classList.remove("hidden");
        
        // Show Parent Accounts also in SEARCH mode
        if (shipStreet.value.trim()) {
             // Re-populate if empty or ensure visible
             if (!document.getElementById("results").hasChildNodes() || document.getElementById("results").innerHTML === "") {
                 document.getElementById("results").innerHTML = "Searching related accounts...";
                 searchAccountsByAddress(shipStreet.value.trim()).then(renderAccounts);
             }
        } else {
             document.getElementById("results").innerHTML = "<p style='color:#64748b;'>Enter shipping address to see suggested parent accounts.</p>";
        }
        
        // Reset contact dropdown - will be populated when account is selected
        resetContactSelect();
      }
    }


    function enableManualBillingEntry() {
      ["billStreet", "billCity", "billProvince", "billPostal", "billCountry"]
        .forEach(id => document.getElementById(id).disabled = false);
      
      // Update status badge
      const statusBadge = document.getElementById("billingAddressStatus");
      if (statusBadge) {
        statusBadge.textContent = "Editable";
        statusBadge.style.background = "#dcfce7";
        statusBadge.style.color = "#166534";
      }
    }

    function disableManualBillingEntry() {
      ["billStreet", "billCity", "billProvince", "billPostal", "billCountry"]
        .forEach(id => document.getElementById(id).disabled = true);
      
      // Update status badge
      const statusBadge = document.getElementById("billingAddressStatus");
      if (statusBadge) {
        statusBadge.textContent = "Read-only";
        statusBadge.style.background = "#e2e8f0";
        statusBadge.style.color = "#64748b";
      }
    }

    // Enable or disable billing address fields
    function setBillingDisabled(disabled) {
      ["billStreet", "billCity", "billProvince", "billPostal", "billCountry"]
        .forEach(id => {
          const el = document.getElementById(id);
          if (el) el.disabled = disabled;
        });
      
      // Update status badge
      const statusBadge = document.getElementById("billingAddressStatus");
      if (statusBadge) {
        if (disabled) {
          statusBadge.textContent = "Read-only";
          statusBadge.style.background = "#e2e8f0";
          statusBadge.style.color = "#64748b";
        } else {
          statusBadge.textContent = "Editable";
          statusBadge.style.background = "#dcfce7";
          statusBadge.style.color = "#166534";
        }
      }
    }


    async function searchBillingAccount(query) {
      if (query.length < 3) return;

      const box = document.getElementById("billingSearchResults");
      box.innerHTML = "<div>Searching...</div>";

      // Search by Account Name, Email, Phone, or Billing/Shipping Address
      const criteria = `((Account_Name:starts_with:${query}) OR (Email:starts_with:${query}) OR (Phone:starts_with:${query}) OR (Billing_Street:starts_with:${query}) OR (Shipping_Street:starts_with:${query}) OR (Billing_City:starts_with:${query}))`;

      try {
        const res = await ZOHO.CRM.API.searchRecord({
          Entity: "Accounts",
          Type: "criteria",
          Query: criteria
        });

        console.log("Search response", res);

        box.innerHTML = "";

        if (!res.data || res.data.length === 0) {
          box.innerHTML = `<div class="no-result">No accounts found</div>`;
          return;
        }

        res.data.forEach(acc => {
          const div = document.createElement("div");
          div.className = "search-item";
          
          const name = acc.Account_Name || "Unnamed Account";
          const phone = acc.Phone || "";
          const billingAddr = formatBillingAddress(acc);
          
          div.innerHTML = `
            <div style="font-weight:600;">${name}</div>
            <div style="font-size:12px; color:#64748b;">
              ${phone ? `üìû ${phone}` : ""}
              ${phone && billingAddr !== "Billing address not available" ? " ‚Ä¢ " : ""}
              ${billingAddr !== "Billing address not available" ? `üìç ${billingAddr}` : ""}
            </div>
          `;
          
          div.onclick = () => handleSearchBillingSelection(acc);
          box.appendChild(div);
        });

      } catch (err) {
        console.error("Account search failed", err);
        box.innerHTML = `<div class="no-result">Search error occurred</div>`;
      }
    }


    function handleSearchBillingSelection(acc) {
      // Set billing account state
      selectedBillingAccount = acc.id;
      selectedBookingAccount = acc.id;

      billingAccountUsage.sourceAccountId = acc.id;
      billingAccountUsage.mode = "USE_EXISTING";  // Default to using existing account

      // Cache the account data for reuse when switching modes
      cachedAccountData = acc;

      // Hide search UI
      document.getElementById("billingSearchBox").classList.add("hidden");

      // Render ONLY this account in Parent Accounts
      renderAccounts([acc]);
      selectAccountCard(acc.id);
      // Force select it visually
      setTimeout(() => {
        selectAccountCard(acc.id);
      }, 0);

      // Show usage options (this also shows account details, contact section, and fetches contacts)
      if (shouldShowBillingUsage()) {
        showBillingAccountUsageOptions();
      }

      // Populate account details fields (always visible)
      populateAccountDetailsFields(acc);

      // Show contact section (contacts already fetched by showBillingAccountUsageOptions)
      document.getElementById("billingContactSection").classList.remove("hidden");

      // Populate and show billing address fields from the selected account
      billStreet.value = acc.Billing_Street || "";
      billCity.value = acc.Billing_City || "";
      billProvince.value = acc.Billing_State || "";
      billPostal.value = formatCanadianPostal(acc.Billing_Code) || "";
      billCountry.value = acc.Billing_Country || "";

      document.getElementById("manualBillingFields").classList.remove("hidden");
      enableManualBillingEntry(); // Enable editing
    }


    function selectAccountCard(accountId) {
      document.querySelectorAll(".account-card").forEach(card => {
        card.classList.remove("selected");
        const radio = card.querySelector("input[type='radio']");
        if (radio) radio.checked = false;
      });

      const card = document.querySelector(`.account-card[data-id="${accountId}"]`);
      if (!card) return;

      card.classList.add("selected");
      const radio = card.querySelector("input[type='radio']");
      if (radio) radio.checked = true;
    }


    function toggleBillingAddress() {
      if (sameAsShipping && sameAsShipping.checked) {
        copyShippingToBilling();
        setBillingDisabled(true);
      } else {
        setBillingDisabled(false);
      }
    }

    function selectBelongsRecord(record) {
      selectedBelongsRecord = record;

      const input = document.getElementById("belongsSearchInput");
      input.value =
        belongsSource === "ACCOUNT"
          ? record.Account_Name
          : record.Full_Name;

      document.getElementById("belongsSearchResults").classList.add("hidden");

      if (belongsSource === "CONTACT") {
        selectedContact = record;
        prefillContactFields(record);
        showAttachedAccount(record);
      } else {
        hideAttachedAccount();
      }
    }

    function prefillContactFields(record) {
      const displayName =
        record.Full_Name ||
        `${record.First_Name || ""} ${record.Last_Name || ""}`.trim();

      if (contactName) contactName.value = displayName || "";
      if (contactEmail)
        contactEmail.value = record.Email || record.Email_Address || "";
      if (contactPhone)
        contactPhone.value = formatPhoneDisplay(record.Phone || record.Mobile) || "";
    }

    function getBelongsRecordPayload() {
      if (!selectedBelongsRecord) return null;

      const payload = {
        id: selectedBelongsRecord.id
      };

      if (belongsSource === "ACCOUNT") {
        const accountName = selectedBelongsRecord.Account_Name;
        payload.name =
          typeof accountName === "string"
            ? accountName
            : accountName?.name || accountName?.value || "";
      }

      if (belongsSource === "CONTACT") {
        const contactName =
          selectedBelongsRecord.Full_Name ||
          `${selectedBelongsRecord.First_Name || ""} ${selectedBelongsRecord.Last_Name || ""}`.trim();
        payload.name = contactName || "";

        const linkedAccount = selectedBelongsRecord.Account_Name;
        if (linkedAccount && (linkedAccount.id || linkedAccount.value)) {
          payload.accountId = linkedAccount.id || linkedAccount.value;
        }
      }

      return payload;
    }

    function showAttachedAccount(contactRecord) {
      console.log("showattached account", contactRecord);

      const label = document.getElementById("attachedAccountLabel");
      const input = document.getElementById("attachedAccountInput");

      if (contactRecord.Account_Name && contactRecord.Account_Name.name) {
        input.value = contactRecord.Account_Name.name;
      } else {
        input.value = "No account linked";
      }

      label.classList.remove("hidden");
      input.classList.remove("hidden");
    }

    function selectBillingAccount(accountId) {
      selectedBillingAccount = accountId;
      billingAccountUsage.sourceAccountId = accountId;
      billingAccountUsage.mode = "USE_EXISTING";  // Default to using existing account

      document.getElementById("billingSearchBox").classList.add("hidden");

      showBillingAccountUsageOptions();
    }

    function hideAttachedAccount() {
      document.getElementById("attachedAccountLabel").classList.add("hidden");
      document.getElementById("attachedAccountInput").classList.add("hidden");
      document.getElementById("attachedAccountInput").value = "";
    }


    function populateBelongsToDropdown() {
      const select = document.getElementById("belongsTo");

      // Only account-based options for billing (exclude TENANT, INDIVIDUAL_CLIENT, STAFF)
      BELONGS_TO_OPTIONS
        .filter(opt => opt.source === "ACCOUNT")
        .forEach(opt => {
          const option = document.createElement("option");
          option.value = opt.value;
          option.textContent = opt.label;
          select.appendChild(option);
        });
    }


    function hasBillingAddress(lead) {
      return Boolean(
        lead.Billing_Street ||
        lead.Billing_City ||
        lead.Billing_Province ||
        lead.Billing_Country ||
        lead.Billing_Postal_Code
      );
    }

    // REMOVED: Duplicate populateBillingFromLead(lead) function
    // Using the version at line ~3311 that uses initialLeadDetails instead


    async function searchBelongsEntity() {
      const q = document.getElementById("belongsSearchInput").value.trim();
      const resultsBox = document.getElementById("belongsSearchResults");

      if (q.length < 3) {
        resultsBox.classList.add("hidden");
        return;
      }

      const entity = belongsSource === "ACCOUNT" ? "Accounts" : "Contacts";
      const criteria =
        belongsSource === "ACCOUNT"
          ? `(Account_Name:starts_with:${q})`
          : `(Full_Name:starts_with:${q})`;

      const res = await ZOHO.CRM.API.searchRecord({
        Entity: entity,
        Type: "criteria",
        Query: criteria
      });

      resultsBox.innerHTML = "";
      resultsBox.classList.remove("hidden");

      if (!res.data || res.data.length === 0) {
        resultsBox.innerHTML = "<div>No records found</div>";
        return;
      }

      res.data.forEach(r => {
        const div = document.createElement("div");
        div.textContent =
          belongsSource === "ACCOUNT" ? r.Account_Name : r.Full_Name;

        // ‚úÖ THIS IS THE KEY FIX
        div.onclick = () => selectBelongsRecord(r);

        resultsBox.appendChild(div);
      });
    }



    const loadLeadDetails = async (leadId) => {
      if (!ZOHO || !ZOHO.CRM || !ZOHO.CRM.API) {
        return null;
      }
      try {
        const lead = await ZOHO.CRM.API.getRecord({
          Entity: "Leads",
          RecordID: leadId
        });
        return lead;
      } catch (error) {
        console.error("Error loading lead:", error);
        return null;
      }
    }

    //  show address in fields
    function getLeadAddress(lead) {
      return {
        street:
          lead.Mailing_Street ||
          lead.Street ||
          lead.Address ||
          "",
        city:
          lead.Mailing_City ||
          lead.City ||
          "",
        state:
          lead.Mailing_State ||
          lead.State ||
          "",
        postal:
          lead.Mailing_Code ||
          lead.Zip_Code ||
          "",
        country:
          lead.Mailing_Country ||
          lead.Country ||
          ""
      };
    }

    function getLeadBillingAddress(lead) {
      return {
        street:
          lead.Billing_Street ||
          lead.Billing_Address ||
          "",
        city:
          lead.Billing_City ||
          "",
        state:
          lead.Billing_State ||
          "",
        postal:
          lead.Billing_Code ||
          "",
        country:
          lead.Billing_Country ||
          ""
      };
    }

    const searchBtn = document.getElementById("searchBtn");
    if (searchBtn) {
      searchBtn.onclick = async () => {
        const resultsEl = document.getElementById("results");
        if (resultsEl) resultsEl.innerHTML = "Searching...";

      const accounts = await searchAccountsByAddress(shipStreet.value);
      renderAccounts(accounts);
    };
    }


    function hasAnyAddress(address) {
      if (!address) return false;
      return Boolean(
        (address.street && address.street.trim()) ||
        (address.city && address.city.trim()) ||
        (address.state && address.state.trim()) ||
        (address.postal && address.postal.trim()) ||
        (address.country && address.country.trim())
      );
    }


    /* ---------- ACCOUNT DECISION HANDLER ---------- */
    function handleAccountDecision() {
      if (!accountDecision || !newAccountName || !newAccountNameLabel) return;

      if (accountDecision.value === "NEW") {
        newAccountNameLabel.style.display = "block";
        newAccountName.style.display = "block";
        newAccountName.required = true;
      } else {
        newAccountNameLabel.style.display = "none";
        newAccountName.style.display = "none";
        newAccountName.required = false;
        newAccountName.value = "";
      }
    }

    function resetAccountSearch() {
      if (accountSearch) accountSearch.value = "";
      if (accountResults) {
        accountResults.classList.add("hidden");
        accountResults.innerHTML = "";
      }
      selectedAccount = null;
    }
    // helper function
    function syncBillingWithShipping() {
      billStreet.value = shipStreet.value;
      billCity.value = shipCity.value;
      billProvince.value = shipProvince.value;
      billPostal.value = shipPostal.value;
      billCountry.value = shipCountry.value;

    }

    // Duplicate function - keeping for backwards compatibility
    function toggleBillingAddressLegacy() {
      const same = sameAsShipping ? sameAsShipping.checked : false;

      ["billStreet", "billCity", "billProvince", "billPostal", "billCountry"].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.disabled = same;
      });

      if (same) {
        syncBillingWithShipping();
      }
    }

    // Auto-sync when shipping changes
    ["shipStreet", "shipCity", "shipProvince", "shipPostal", "shipCountry"].forEach(id => {
      document.getElementById(id).addEventListener("input", () => {
        tryAutoSearchAccounts();
      });
    });

    /* ---------- ROLE DROPDOWN ---------- */
    function toggleRoleDropdown() {
      if (!roleDropdown) return;
      roleDropdown.classList.toggle("hidden");
      const multiSelect = document.querySelector(".multi-select");
      if (multiSelect) {
        multiSelect.classList.toggle("active");
      }
    }

    // Close dropdown when clicking outside
    document.addEventListener("click", function (event) {
      if (roleDropdown && !roleDropdown.contains(event.target) &&
        !event.target.closest(".multi-select")) {
        roleDropdown.classList.add("hidden");
        const multiSelect = document.querySelector(".multi-select");
        if (multiSelect) {
          multiSelect.classList.remove("active");
        }
      }
    });

    function updateRoles() {
      const checkboxes = document.querySelectorAll(
        '#roleDropdown input[type="checkbox"]'
      );

      selectedContactRoles = [];

      let hasBilling = false;
      let hasTenant = false;

      checkboxes.forEach(cb => {
        if (cb.checked) {
          selectedContactRoles.push(cb.value);
          if (cb.value === "BILLING") hasBilling = true;
          if (cb.value === "TENANT") hasTenant = true;
        }
      });

      // üö´ RULE: Billing + Tenant cannot coexist
      if (hasBilling && hasTenant) {
        // Decide precedence (recommended: last clicked loses)
        const tenantCheckbox = document.querySelector(
          '#roleDropdown input[value="TENANT"]'
        );

        if (tenantCheckbox) tenantCheckbox.checked = false;

        selectedContactRoles = selectedContactRoles.filter(
          r => r !== "TENANT"
        );

        alert("Tenant cannot be selected with Billing.");
      }

      // üîê Auto-control Do Not Invoice
      const doNotInvoiceCheckbox = document.getElementById("doNotInvoice");

      if (selectedContactRoles.includes("TENANT")) {
        doNotInvoiceCheckbox.checked = true;
        doNotInvoiceCheckbox.disabled = true;
      } else {
        doNotInvoiceCheckbox.disabled = false;
      }

      renderSelectedRoles();
    }


    function renderSelectedRoles() {
      if (!selectedRoles) return;
      selectedRoles.innerHTML = "";

      if (selectedContactRoles.length === 0) {
        selectedRoles.innerText = "Select role(s)";
        selectedRoles.classList.add("empty");
        return;
      }

      selectedRoles.classList.remove("empty");
      selectedContactRoles.forEach(role => {
        const span = document.createElement("span");
        span.className = "role-chip";
        span.innerText = role;
        selectedRoles.appendChild(span);
      });
    }

    /* ---------- CONTACT SELECTION ---------- */

    // Legacy function - kept for compatibility but simplified
    function toggleContactMode() {
      // No longer uses radio buttons - handled by select dropdown
      // This function is kept for backwards compatibility with any remaining calls
    }

    function selectContactFromSearch(c) {
      // Legacy function - now handled by selectContactFromDropdown
      selectContactFromDropdown(c);
    }

    // Check if user is creating new contact or using existing
    function isCreatingNewContact() {
      const contactSelect = document.getElementById("contactSelect");
      return !contactSelect || contactSelect.value === "NEW";
    }

    /* ---------- ACCOUNT SEARCH ---------- */
    async function searchAccount() {
      if (!accountSearch || !accountResults) return;

      const q = accountSearch.value.trim();
      if (q.length < 3) {
        accountResults.classList.add("hidden");
        accountResults.innerHTML = "";
        return;
      }

      if (!ZOHO || !ZOHO.CRM || !ZOHO.CRM.API) {
        accountResults.innerHTML = "<div>Zoho SDK not available</div>";
        accountResults.classList.remove("hidden");
        return;
      }

      let accVal = await ZOHO.CRM.API.getRecord({
        Entity: "Accounts",
      });

      console.log("zoho accounts", accVal);


      ZOHO.CRM.API.searchRecord({
        Entity: "Accounts",
        Type: "criteria",
        Query: `(Account_Name:starts_with:${q})`
      }).then(res => {
        console.log("zoho accounts search", res);
        accountResults.innerHTML = "";
        accountResults.classList.remove("hidden");

        if (!res.data || res.data.length === 0) {
          accountResults.innerHTML = "<div style='padding: 12px; color: #64748b;'>No accounts found</div>";
          return;
        }

        res.data.forEach(a => {
          const div = document.createElement("div");
          div.innerText = a.Account_Name || "Unnamed Account";
          div.onclick = () => {
            selectedAccount = a;
            accountSearch.value = a.Account_Name || "";
            accountResults.classList.add("hidden");
            if (accountDecision) {
              accountDecision.value = "USE";
              handleAccountDecision();
            }
          };
          accountResults.appendChild(div);
        });
      }).catch(err => {
        console.error("Account search error:", err);
        accountResults.innerHTML = "<div style='padding: 12px; color: #ef4444;'>Search error occurred</div>";
        accountResults.classList.remove("hidden");
      });
    }

    /* ---------- CONTACT SEARCH ---------- */
    async function searchContact() {
      if (!contactSearch || !contactResults) return;

      const q = contactSearch.value.trim();
      if (q.length < 3) {
        contactResults.classList.add("hidden");
        contactResults.innerHTML = "";
        return;
      }

      if (!ZOHO || !ZOHO.CRM || !ZOHO.CRM.API) {
        contactResults.innerHTML = "<div>Zoho SDK not available</div>";
        contactResults.classList.remove("hidden");
        return;
      }

      let contactVal = await ZOHO.CRM.API.getRecord({
        Entity: "Contacts",
      });

      console.log("zoho contacts", contactVal);

      ZOHO.CRM.API.searchRecord({
        Entity: "Contacts",
        Type: "criteria",
        Query: `(Full_Name:starts_with:${q})`
      }).then(res => {
        contactResults.innerHTML = "";
        contactResults.classList.remove("hidden");

        if (!res.data || res.data.length === 0) {
          contactResults.innerHTML = "<div style='padding: 12px; color: #64748b;'>No contacts found</div>";
          return;
        }

        res.data.forEach(c => {
          const div = document.createElement("div");
          const displayName = c.Full_Name || `${c.First_Name || ""} ${c.Last_Name || ""}`.trim() || "Unnamed Contact";
          div.innerText = displayName;
          div.onclick = () => {
            selectedContact = c;
            if (contactName) contactName.value = displayName;
            if (contactComm) {
              if (contactEmail) contactEmail.value = c.Email || "";
              if (contactPhone) contactPhone.value = formatPhoneDisplay(c.Phone || c.Mobile) || "";
            }
            contactResults.classList.add("hidden");
          };
          contactResults.appendChild(div);
        });
      }).catch(err => {
        console.error("Contact search error:", err);
        contactResults.innerHTML = "<div style='padding: 12px; color: #ef4444;'>Search error occurred</div>";
        contactResults.classList.remove("hidden");
      });
    }

    /* ---------- VALIDATION ---------- */
    function validateRoles() {
      const required = {
        PARENT: ["BILLING"],
        LANDLORD: ["BILLING"],
        HOUSEHOLD: ["BILLING", "BOOKING"],
        DIRECT: ["BILLING"],
        PMC: ["BILLING", "ADMIN"],
        SUB: ["BILLING"]
      };

      if (!accountType || !accountType.value) return true; // Skip if no account type selected

      const req = required[accountType.value] || [];
      return req.every(r => selectedContactRoles.includes(r));
    }

    function validateForm() {
      const errors = [];

      // Check if billing is same as shipping (early check)
      const billingSameCheckbox = document.getElementById("billingSameAsShipping");
      const isBillingSame = billingSameCheckbox && billingSameCheckbox.checked;

      // Skip billing "Belongs To" validation if billing is same as shipping
      if (!isBillingSame && !belongsValue) {
        errors.push("Belongs To selection is required");
      }
      
      // If billing is same as shipping, require shipping "Belongs To"
      if (isBillingSame) {
        const shippingBelongsTo = document.getElementById("shippingBelongsTo");
        if (!shippingBelongsTo?.value) {
          errors.push("Shipping 'Belongs To' selection is required when billing is same as shipping");
        }
      } 
      // Validate contact selection
      else if (belongsSource === "CONTACT") {
         const contactSelect = document.getElementById("contactSelect");
         const isUsingExisting = contactSelect && contactSelect.value !== "NEW";
         
         if (isUsingExisting && !selectedContact) {
             errors.push("Please select a contact or choose 'Create New Contact'.");
         }
      }

      if (!contactName || !contactName.value.trim()) {
        errors.push("Contact Name is required");
      }

      // if (!contactComm || !contactComm.value.trim()) {
      //   errors.push("Email or Phone is required");
      // }

      if (selectedContactRoles.length === 0) {
        errors.push("At least one Contact Role is required");
      }

      if (!validateRoles()) {
        const accountTypeName = accountType ? accountType.options[accountType.selectedIndex]?.text : "selected account type";
        errors.push(`Required contact roles missing for ${accountTypeName}`);
      }

      // Validation removed - centralBilling is hidden with default "NO"
      // if (!centralBilling || !centralBilling.value) {
      //   errors.push("Billing centralized status is required");
      // }

      const requiresServiceLocation = belongsSource === "CONTACT";

      // Shipping and Billing address validation removed - fields are now optional
      // if (requiresServiceLocation) {
      //   if (!addressType || !addressType.value) {
      //     // errors.push("Address Type is required");
      //   }
      //   if (!shipStreet.value.trim()) {
      //     errors.push("Street Address (Shipping) is required");
      //   }
      //   if (!shipCity.value.trim()) {
      //     errors.push("City (Shipping) is required");
      //   }
      //   if (!shipProvince.value.trim()) {
      //     errors.push("Province (Shipping) is required");
      //   }
      //   if (!shipPostal.value.trim()) {
      //     errors.push("Postal Code (Shipping) is required");
      //   } else if (!isValidCanadianPostal(shipPostal.value)) {
      //     errors.push("Invalid Canadian postal code format for Shipping (use: A1A 1A1)");
      //   }
      //   if (!shipCountry.value.trim()) {
      //      errors.push("Country (Shipping) is required");
      //   }
      // }

      // Billing address validation removed - fields are now optional
      // if (selectedBillingOption === "DIFFERENT") {
      //   if (
      //     !billStreet.value.trim() ||
      //     !billCity.value.trim() ||
      //     !billProvince.value.trim() ||
      //     !billPostal.value.trim() ||
      //     !billCountry.value.trim()
      //   ) {
      //     errors.push("All Billing Address fields are required");
      //   } else if (billPostal.value.trim() && !isValidCanadianPostal(billPostal.value)) {
      //     errors.push("Invalid Canadian postal code format for Billing (use: A1A 1A1)");
      //   }
      // }

      // Check if billing is same as shipping
      const billingSameAsShippingCheckbox = document.getElementById("billingSameAsShipping");
      const isBillingSameAsShipping = billingSameAsShippingCheckbox && billingSameAsShippingCheckbox.checked;
      
      // Skip billing validations if "Billing same as Shipping" is checked
      if (!isBillingSameAsShipping) {
        // Check billing address selection (either old billingOption or new billingAddressOption)
        const billingAddressOption = document.getElementById("billingAddressOption");
        const billingDropdownValue = billingAddressOption ? billingAddressOption.value : "";
        const hasBillingSelection = selectedBillingOption || billingDropdownValue;
        
        // Valid scenarios where booking account is NOT required:
        // - DIFFERENT: manual entry
        // - SEARCHED: searched billing address
        // - CREATE_NEW: creating new from dropdown
        // - SAME_AS_SHIPPING: using shipping address as billing
        // - Dropdown has SEARCHED_* value: searched and selected
        const validWithoutBookingAccount = 
          selectedBillingOption === "DIFFERENT" ||
          selectedBillingOption === "SEARCHED" ||
          selectedBillingOption === "CREATE_NEW" ||
          selectedBillingOption === "SAME" ||
          billingDropdownValue === "CREATE_NEW" ||
          billingDropdownValue === "SAME_AS_SHIPPING" ||
          billingDropdownValue.startsWith("SEARCHED_") ||
          billingDropdownValue.startsWith("LINKED_");
        
        if (!selectedBookingAccount && !selectedBillingAccount && !validWithoutBookingAccount) {
          errors.push("Please select a booking account");
        }
        
        if (!hasBillingSelection) {
          errors.push("Please select a billing address option");
        }
      }

      // Only check SEARCH account if using old billing options (disabled now)
      // if (selectedBillingOption === "SEARCH" && !selectedBillingAccount) {
      //   errors.push("Please select how to use the billing account");
      // }

      // Billing address validation removed - fields are now optional
      // if (selectedBillingOption === "DIFFERENT") {
      //   if (
      //     !billStreet.value ||
      //     !billCity.value ||
      //     !billProvince.value ||
      //     !billPostal.value ||
      //     !billCountry.value
      //   ) {
      //     errors.push("All manual billing address fields are required");
      //   }
      // }

      // billingAccountUsage.mode validation removed - simplified flow

      if (
        selectedContactRoles.includes("BILLING") &&
        selectedContactRoles.includes("TENANT")
      ) {
        errors.push("Contact cannot be both Billing and Tenant.");
      }

      return errors;
    }

    /* ---------- SUBMIT ---------- */
    
    // Helper function to show submit button state
    function setSubmitButtonState(state, message = "") {
      const btn = document.getElementById("submitButton");
      const msgEl = document.getElementById("submitMessage");
      
      // Remove all state classes
      btn.classList.remove("processing", "success", "error");
      msgEl.style.display = "none";
      msgEl.className = "";
      
      switch(state) {
        case "processing":
          btn.disabled = true;
          btn.classList.add("processing");
          btn.innerHTML = `<span style="display: inline-flex; align-items: center; gap: 8px;">
            <svg width="18" height="18" viewBox="0 0 24 24" style="animation: spin 1s linear infinite;">
              <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="3" fill="none" stroke-dasharray="31.4 31.4" stroke-linecap="round"/>
            </svg>
            Processing...
          </span>`;
          break;
        case "success":
          btn.disabled = true;
          btn.classList.add("success");
          btn.innerHTML = `<span style="display: inline-flex; align-items: center; gap: 8px;">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3">
              <polyline points="20 6 9 17 4 12"></polyline>
            </svg>
            Deal Created Successfully!
          </span>`;
          if (message) {
            msgEl.textContent = message;
            msgEl.className = "submit-message-success";
            msgEl.style.display = "block";
          }
          break;
        case "error":
          btn.disabled = false;
          btn.classList.add("error");
          btn.innerHTML = `<span style="display: inline-flex; align-items: center; gap: 8px;">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3">
              <circle cx="12" cy="12" r="10"></circle>
              <line x1="15" y1="9" x2="9" y2="15"></line>
              <line x1="9" y1="9" x2="15" y2="15"></line>
            </svg>
            Error - Click to Retry
          </span>`;
          if (message) {
            msgEl.innerHTML = message;
            msgEl.className = "submit-message-error";
            msgEl.style.display = "block";
          }
          // Auto-reset to normal after 5 seconds
          setTimeout(() => resetSubmitButton(), 5000);
          break;
        default:
          btn.disabled = false;
          btn.textContent = "Confirm & Convert";
      }
    }
    
    // Reset submit button to default state
    function resetSubmitButton() {
      const btn = document.getElementById("submitButton");
      const msgEl = document.getElementById("submitMessage");
      btn.classList.remove("processing", "success", "error");
      btn.disabled = false;
      btn.textContent = "Confirm & Convert";
      msgEl.style.display = "none";
    }
    
    // Start countdown and redirect to Deal page
    function startRedirectCountdown(dealId) {
      const btn = document.getElementById("submitButton");
      const msgEl = document.getElementById("submitMessage");
      
      // Remove all state classes and add success
      btn.classList.remove("processing", "error");
      btn.classList.add("success");
      btn.disabled = true;
      
      let countdown = 3;
      
      // Set button content
      btn.innerHTML = '<span style="display: inline-flex; align-items: center; gap: 8px;"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><polyline points="20 6 9 17 4 12"></polyline></svg>Deal Created Successfully!</span>';
      
      // Function to update message with countdown
      function updateMessage() {
        msgEl.innerHTML = '<div style="text-align: center;"><div style="margin-bottom: 8px;">‚úì Lead has been converted to Deal, Account, and Contact.</div><div style="font-weight: 600; font-size: 15px;">Redirecting to Deal page in <span style="display: inline-flex; align-items: center; justify-content: center; width: 26px; height: 26px; background: #166534; color: white; border-radius: 50%; font-size: 14px; font-weight: 700; margin: 0 4px;">' + countdown + '</span> seconds...</div></div>';
        msgEl.className = "submit-message-success";
        msgEl.style.display = "block";
      }
      
      // Initial display
      updateMessage();
      
      // Countdown interval
      const countdownInterval = setInterval(function() {
        countdown--;
        
        if (countdown > 0) {
          updateMessage();
        } else {
          clearInterval(countdownInterval);
          
          // Update message to show redirecting
          msgEl.innerHTML = '<div style="text-align: center;"><div style="margin-bottom: 8px;">‚úì Lead has been converted to Deal, Account, and Contact.</div><div style="font-weight: 600; font-size: 15px;">üöÄ Redirecting now...</div></div>';
          
          // Redirect to Deal page
          if (dealId) {
            ZOHO.CRM.UI.Record.open({ Entity: "Deals", RecordID: dealId })
              .then(function() {
                console.log("Navigated to Deal:", dealId);
                ZOHO.CRM.UI.Popup.closeReload();
              })
              .catch(function(err) {
                console.error("Error navigating to Deal:", err);
                ZOHO.CRM.UI.Popup.closeReload();
              });
          } else {
            console.log("No Deal ID found, closing widget");
            ZOHO.CRM.UI.Popup.closeReload();
          }
        }
      }, 1000);
    }
    
    async function submitWidget() {
      const errors = validateForm();
      if (errors.length > 0) {
        setSubmitButtonState("error", "‚Ä¢ " + errors.join("<br>‚Ä¢ "));
        return;
      }

      setSubmitButtonState("processing");

      try {
        // Check if billing is same as shipping
        const billingSameCheckbox = document.getElementById("billingSameAsShipping");
        const isBillingSameAsShipping = billingSameCheckbox && billingSameCheckbox.checked;
        
        // Determine scenario: use shipping "Belongs To" if billing same as shipping, otherwise use billing "Belongs To"
        let effectiveScenario = belongsValue;
        if (isBillingSameAsShipping) {
          const shippingBelongsTo = document.getElementById("shippingBelongsTo");
          effectiveScenario = shippingBelongsTo?.value || "LANDLORD"; // Default to LANDLORD if not selected
        }
        
        const needsTenantPayload = effectiveScenario === "TENANT";
        const scenarioPayload = needsTenantPayload
          ? buildTenantPayload(effectiveScenario)
          : buildLandlordPayload(effectiveScenario);

        const billingSupplement = {
          centralized: centralBilling.value,
          usage: billingAccountUsage.mode,
          sourceAccountId: billingAccountUsage.sourceAccountId
        };

        // Build belongs section - use shipping belongs if billing same as shipping
        let belongsPayload;
        if (isBillingSameAsShipping) {
          const shippingBelongsTo = document.getElementById("shippingBelongsTo");
          const shippingBelongsOption = shippingBelongsTo?.options[shippingBelongsTo?.selectedIndex];
          belongsPayload = {
            value: shippingBelongsTo?.value || "LANDLORD",
            label: shippingBelongsOption?.textContent || "Landlord / Owner",
            source: "SHIPPING",
            record: null
          };
        } else {
          belongsPayload = {
            value: belongsValue,
            label: belongsLabel,
            source: belongsSource,
            record: getBelongsRecordPayload()
          };
        }

        const payload = {
          ...scenarioPayload,
          billing: scenarioPayload.billing || billingSupplement,
          belongs: belongsPayload,
          leadId: currentLeadId
        };

        const payloadJson = JSON.stringify(payload);
        console.log("Sending Payload:", payloadJson);

        const result = await ZOHO.CRM.FUNCTIONS.execute(
          "widgetConvertLeadMain",
          { arguments: payloadJson }
        );
        
        console.log("Function Result:", result);

        // ZOHO.CRM.FUNCTIONS.execute returns:
        // { code: 'success', details: { output: '{"code":"success",...}' }, message: 'function executed successfully' }
        // The actual Deluge return value is in result.details.output
        
        let delugeOutput = null;
        
        // Method 1: result.details.output (most common)
        if (result && result.details && result.details.output) {
            console.log("result.details.output", result.details.output);
            console.log("Found output in result.details.output");
            delugeOutput = result.details.output;
        }
        // Method 2: result.output (fallback)
        else if (result && result.output) {
            console.log("Found output in result.output");
            delugeOutput = result.output;
        }
        // Method 3: result itself might be the output
        else if (result && typeof result === "string") {
            console.log("Result is a string, using as output");
            delugeOutput = result;
        }
        
        console.log("Deluge Output (raw):", delugeOutput);

        // Parse the Deluge output string to JSON
        let parsedResult = null;
        if (delugeOutput) {
            if (typeof delugeOutput === "string") {
                try {
                    parsedResult = JSON.parse(delugeOutput);
            } catch (e) {
                    console.warn("Could not parse Deluge output string:", e);
                    // If it's a simple success/error string
                    if (delugeOutput.includes("error")) {
                        throw new Error(delugeOutput);
                    }
                }
            } else {
                parsedResult = delugeOutput;
            }
        }

        console.log("Parsed Deluge Result:", parsedResult);

        if (parsedResult) {
            // Check top-level error from Deluge function
            if (parsedResult.code === "error") {
                throw new Error(parsedResult.message || "Conversion failed");
            }

            // Check nested details error (Deluge function might return {code:"success", details:{...error...}})
            let hasNestedError = false;
            let nestedErrorMessage = "";
            
            if (parsedResult.details) {
                let details = parsedResult.details;
                
                // Handle case where details is a double-encoded string
                if (typeof details === "string") {
                    try { details = JSON.parse(details); } catch (e) {}
                }

                console.log("Deluge Details object:", details);
                console.log("Deluge Details status:", details.status);
                console.log("Deluge Details code:", details.code);

                // Check for Zoho error structures in details
                if (details.status === "error" || details.code === "ID_ALREADY_CONVERTED" || 
                    details.code === "DUPLICATE_DATA" || details.code === "INVALID_DATA" ||
                    details.code === "MANDATORY_NOT_FOUND") {
                    hasNestedError = true;
                    nestedErrorMessage = details.message || details.code || "Backend Error";
                    const errorDetails = details.details && details.details.api_name ? 
                        ` (${details.details.api_name})` : '';
                    nestedErrorMessage += errorDetails;
                }
            }
            
            // If nested error found, throw it
            if (hasNestedError) {
                throw new Error(nestedErrorMessage);
            }
            
            // Only show success if code is "success"
            if (parsedResult.code === "success") {
                // Extract Deal ID from response
                let dealId = null;
                if (parsedResult.details) {
                    let details = parsedResult.details;
                    if (typeof details === "string") {
                        try { details = JSON.parse(details); } catch (e) {}
                    }
                    
                    // Log all keys in details to find the Deal ID
                    console.log("üìã Details keys:", Object.keys(details));
                    console.log("üìã Details.Deals:", details.Deals);
                    console.log("üìã Details.dealId:", details.dealId);
                    console.log("üìã Details.deal_id:", details.deal_id);
                    
                    // Try to get Deal ID from various possible response structures
                    // Zoho's standard conversion returns: { Deals: "deal_id", Accounts: "account_id", Contacts: "contact_id" }
                    dealId = details.Deals ||                           // Direct ID string
                             details.dealId || 
                             details.deal_id || 
                             details.Deal ||                            // Singular
                             (details.Deals && details.Deals.id) ||     // Object with id
                             (details.Deals && Array.isArray(details.Deals) && details.Deals[0]?.id) || // Array
                             details.id || 
                             null;
                    
                    console.log("‚úÖ Extracted Deal ID:", dealId);
                }
                
                // Show success with countdown
                startRedirectCountdown(dealId);
                
        } else {
                throw new Error(parsedResult.message || "Conversion failed");
            }
        } else {
            // No parsedResult - check if original result indicates success
            if (result && result.code === "success" && result.message === "function executed successfully") {
                // This is the wrapper success, but we don't have the actual output
                console.warn("Function executed but no output received from Deluge");
                startRedirectCountdown(null);
            } else {
                throw new Error("No response from server");
            }
        }

      } catch (error) {
        console.error(error);
        setSubmitButtonState("error", error.message || "Unexpected error occurred");
      }
    }



    function buildLandlordPayload(scenario = "LANDLORD") {
      // Check if billing is same as shipping
      const billingSameAsShippingCheckbox = document.getElementById("billingSameAsShipping");
      const isBillingSameAsShipping = billingSameAsShippingCheckbox && billingSameAsShippingCheckbox.checked;
      
      // Get existing Service Location ID if selected
      const existingServiceLocationId = shippingSelectedAddress?.serviceLocationId || 
        shippingSelectedAddress?.id || 
        null;
      
      const shippingAddress = {
        existingId: existingServiceLocationId,
        isNew: !existingServiceLocationId,
        roomLocation: shipRoomLocation.value.trim(),
        street: shipStreet.value.trim(),
        city: shipCity.value.trim(),
        province: shipProvince.value.trim(),
        postal: shipPostal.value.trim(),
        country: shipCountry.value.trim()
      };

      let existingBillingAddressId = null;
      let existingBillingAccountId = null;
      let isCreatingNewBilling = true;
      let billingAddress;
      
      // If billing is same as shipping, use shipping values for billing
      if (isBillingSameAsShipping) {
        billingAddress = {
          existingId: null,
          accountId: null,
          isNew: true,
          sameAsShipping: true,
          street: shipStreet.value.trim(),
          city: shipCity.value.trim(),
          province: shipProvince.value.trim(),
          postal: shipPostal.value.trim(),
          country: shipCountry.value.trim()
        };
      } else {
        // Get existing Billing Address ID if selected from dropdown
        const billingSelect = document.getElementById("billingAddressOption");
        const selectedBillingOption_element = billingSelect?.options[billingSelect?.selectedIndex];
        
        // Only extract billing data if NOT creating new
        isCreatingNewBilling = billingSelect?.value === "CREATE_NEW" || billingSelect?.value === "";
        
        if (!isCreatingNewBilling && selectedBillingOption_element?.dataset?.billingData) {
          const billingData = JSON.parse(selectedBillingOption_element.dataset.billingData);
          existingBillingAddressId = billingData.billingAddressId || null;
          existingBillingAccountId = billingData.accountId || null;
        }
        
        // Fallback to selectedBillingAccount if available (and not creating new)
        if (!isCreatingNewBilling && !existingBillingAccountId && selectedBillingAccount?.id) {
          existingBillingAccountId = selectedBillingAccount.id;
        }

      // Always include billing address from form fields (user can edit in all cases)
        billingAddress = {
          existingId: existingBillingAddressId,
          accountId: existingBillingAccountId,
          isNew: isCreatingNewBilling || !existingBillingAddressId,
            street: billStreet.value.trim(),
            city: billCity.value.trim(),
            province: billProvince.value.trim(),
            postal: billPostal.value.trim(),
            country: billCountry.value.trim()
      };
      }
      
      // Flag to indicate if billing address was modified from original account
      const billingAddressModified = selectedBillingOption === "DIFFERENT" || 
        billingAccountUsage.mode === "SAME_ACCOUNT_DIFFERENT_ADDRESS" ||
        billingAccountUsage.mode === "NEW_ACCOUNT";

      // --- ACCOUNT LOGIC ---
      const accountPayload = {
        type: scenario
      };

      let mode = billingAccountUsage.mode; // USE_EXISTING | SAME_ACCOUNT_DIFFERENT_ADDRESS | NEW_ACCOUNT

      // If billing is same as shipping, use shipping contact details for account
      if (isBillingSameAsShipping) {
        accountPayload.existingId = null;
        accountPayload.newName = (shippingContactName?.value?.trim() || "New Account") + " Account";
        accountPayload.newPhone = stripPhoneFormatting(shippingContactPhone?.value) || "";
        accountPayload.newEmail = shippingContactEmail?.value?.trim() || "";
      }
      // If user explicitly chose "Create a new account" (Step 4 logic) or creating new billing
      else if (mode === "NEW_ACCOUNT" || selectedBillingOption === "DIFFERENT" || isCreatingNewBilling) {
        accountPayload.existingId = null;
        // Use account name field if available, otherwise contact name
        const accountNameEl = document.getElementById("accountName");
        const accountPhoneEl = document.getElementById("accountPhone");
        const accountEmailEl = document.getElementById("accountEmail");
        accountPayload.newName = accountNameEl?.value?.trim() || (contactName.value.trim() || "New Landlord") + " Account";
        accountPayload.newPhone = stripPhoneFormatting(accountPhoneEl?.value) || "";
        accountPayload.newEmail = accountEmailEl?.value?.trim() || "";
      }
      // If user explicitly chose to use existing
      else if (mode === "USE_EXISTING" || mode === "SAME_ACCOUNT_DIFFERENT_ADDRESS") {
        accountPayload.existingId = selectedBillingAccount || selectedBookingAccount || null;
      }
      // Fallback: if no specific mode set (e.g. didn't open billing options), try to use selected account
      else {
         accountPayload.existingId = selectedBillingAccount || selectedBookingAccount || null;
      }

      // If user chose "Use booking account billing address" (SAME) and selected an account
      if (!isBillingSameAsShipping && selectedBillingOption === "SAME" && selectedBookingAccount) {
         accountPayload.existingId = selectedBookingAccount;
         mode = "USE_EXISTING"; // Force mode to USE_EXISTING for clarity
      }

      // For existing account: Always include account details from form for update
      if (accountPayload.existingId) {
        const accountNameEl = document.getElementById("accountName");
        const accountPhoneEl = document.getElementById("accountPhone");
        const accountEmailEl = document.getElementById("accountEmail");
        
        // Check if account form has values
        const hasAccountFormValues = accountNameEl?.value?.trim() || 
                                     accountPhoneEl?.value?.trim() || 
                                     accountEmailEl?.value?.trim();
        
        if (hasAccountFormValues) {
          // Include updated details from account form
        accountPayload.updateWithContact = true;
          accountPayload.updateName = accountNameEl?.value?.trim() || "";
          accountPayload.updatePhone = stripPhoneFormatting(accountPhoneEl?.value) || "";
          accountPayload.updateEmail = accountEmailEl?.value?.trim() || "";
          console.log("Including account updates:", {
            name: accountPayload.updateName,
            phone: accountPayload.updatePhone,
            email: accountPayload.updateEmail
          });
        }
      }

      // Always include billing address for update (user can edit in all cases)
      // Mark for update if using existing account
      if (accountPayload.existingId && billingAddress) {
        accountPayload.updateBillingAddress = true;
        accountPayload.newBillingAddress = billingAddress;
      }

      // Determine contact roles based on checkbox state
      const shippingBelongsTo = document.getElementById("shippingBelongsTo")?.value;
      const billingBelongsTo = belongsValue; // Billing "Belongs To"
      
      let contactRoles;
      let accountTypeValue;
      
      if (isBillingSameAsShipping) {
        // CHECKED: Shipping belongs to sets PARENT position (account type + contact role)
        contactRoles = getRolesForBelongsTo(shippingBelongsTo, true); // Parent position
        accountTypeValue = getAccountTypeForBelongsTo(shippingBelongsTo);
        // Update account payload with the determined type
        accountPayload.type = accountTypeValue;
      } else {
        // UNCHECKED: 
        // - Shipping belongs to sets CHILD contact type
        // - Billing belongs to sets PARENT account type + contact type
        contactRoles = getRolesForBelongsTo(shippingBelongsTo, false); // Child position
        accountTypeValue = getAccountTypeForBelongsTo(billingBelongsTo);
        accountPayload.type = accountTypeValue;
      }

      return {
        scenario,

        account: accountPayload,

        contact: {
          // Use shipping contact if selected from address dropdown, otherwise use billing contact
          existingId: shippingSelectedContact?.id || selectedContact?.id || null,
          name: document.getElementById("shippingContactName")?.value?.trim() || contactName.value.trim(),
          email: document.getElementById("shippingContactEmail")?.value?.trim() || contactEmail.value.trim(),
          phone: stripPhoneFormatting(document.getElementById("shippingContactPhone")?.value || contactPhone.value),
          roles: selectedContactRoles,  // Use user-selected checkbox roles instead of belongsTo-derived roles
          doNotInvoice: false
        },

        billing: {
          centralized: centralBilling.value,
          usage: mode,
          sourceAccountId: billingAccountUsage.sourceAccountId,
          addressModified: billingAddressModified
        },

        serviceLocation: {
          existingId: existingServiceLocationId,
          isNew: !existingServiceLocationId,
          addressType: addressType?.value || "",
          ...shippingAddress
        },

        shippingAddress,
        billingAddress
      };
    }

    function buildTenantPayload(scenario = "TENANT") {
      // Check if billing is same as shipping
      const billingSameAsShippingCheckbox = document.getElementById("billingSameAsShipping");
      const isBillingSameAsShipping = billingSameAsShippingCheckbox && billingSameAsShippingCheckbox.checked;
      
      // Capture New Landlord Details
      const newLandlordNameVal = document.getElementById("newLandlordName").value.trim();
      const newLandlordPhoneVal = document.getElementById("newLandlordPhone").value.trim();
      const newLandlordEmailVal = document.getElementById("newLandlordEmail").value.trim();

      // Get existing Service Location ID if selected
      const existingServiceLocationId = shippingSelectedAddress?.serviceLocationId || 
        shippingSelectedAddress?.id || 
        null;

      // Determine Landlord (Account) Strategy
      let landlordAccountId = null;
      let createNewLandlord = false;
      let landlordAddress = null;

      let existingBillingAddressId = null;
      let existingBillingAccountId = null;
      let isCreatingNewBilling = true;
      let billingAddress;
      
      // If billing is same as shipping, use shipping values for billing
      if (isBillingSameAsShipping) {
        billingAddress = {
          existingId: null,
          accountId: null,
          isNew: true,
          sameAsShipping: true,
          street: shipStreet.value.trim(),
          city: shipCity.value.trim(),
          province: shipProvince.value.trim(),
          postal: shipPostal.value.trim(),
          country: shipCountry.value.trim()
        };
        createNewLandlord = true;
      } else {
        // Get existing Billing Address ID if selected from dropdown
        const billingSelect = document.getElementById("billingAddressOption");
        const selectedBillingOption_element = billingSelect?.options[billingSelect?.selectedIndex];
        
        // Only extract billing data if NOT creating new
        isCreatingNewBilling = billingSelect?.value === "CREATE_NEW" || billingSelect?.value === "";
        
        if (!isCreatingNewBilling && selectedBillingOption_element?.dataset?.billingData) {
          const billingData = JSON.parse(selectedBillingOption_element.dataset.billingData);
          existingBillingAddressId = billingData.billingAddressId || null;
          existingBillingAccountId = billingData.accountId || null;
        }

      // Always capture billing address from form (user can edit in all cases)
        billingAddress = {
          existingId: existingBillingAddressId,
          accountId: existingBillingAccountId,
          isNew: isCreatingNewBilling || !existingBillingAddressId,
        street: billStreet.value.trim(),
        city: billCity.value.trim(),
        province: billProvince.value.trim(),
        postal: billPostal.value.trim(),
        country: billCountry.value.trim()
      };
      }

      // 0. If billing is same as shipping, use shipping contact info for landlord
      if (isBillingSameAsShipping) {
        createNewLandlord = true;
        landlordAddress = billingAddress;
      }
      // 1. Search Logic
      else if (selectedBillingOption === "SEARCH") {
        if (billingAccountUsage.mode === "USE_EXISTING") {
           landlordAccountId = billingAccountUsage.sourceAccountId;
           landlordAddress = billingAddress; // Include edited address
        } else if (billingAccountUsage.mode === "NEW_ACCOUNT") {
           // Creating new landlord based on searched account's address or similar
           createNewLandlord = true;
           landlordAccountId = billingAccountUsage.sourceAccountId; 
           landlordAddress = billingAddress;
        } else if (billingAccountUsage.mode === "SAME_ACCOUNT_DIFFERENT_ADDRESS") {
           landlordAccountId = billingAccountUsage.sourceAccountId;
           landlordAddress = billingAddress;
        }
      }
      // 2. Same as Booking
      else if (selectedBillingOption === "SAME") {
         if (!selectedBookingAccount) {
            throw new Error("No booking account selected to use as Landlord.");
         }
         landlordAccountId = selectedBookingAccount;
         landlordAddress = billingAddress; // Include edited address
      }
      // 3. Manual Entry (Create New Landlord)
      else if (selectedBillingOption === "DIFFERENT") {
         createNewLandlord = true;
         landlordAddress = billingAddress;
      }
      // 4. Create New Billing Address (from dropdown selection)
      else if (isCreatingNewBilling) {
         createNewLandlord = true;
         landlordAddress = billingAddress;
      }

      if (!landlordAccountId && !createNewLandlord) {
        throw new Error("Tenant requires a Landlord (Billing Account) selection.");
      }

      // Validation for New Landlord (skip if billing same as shipping - will use contact name)
      if (createNewLandlord && !isBillingSameAsShipping && !newLandlordNameVal) {
         throw new Error("Please enter a name for the new Landlord.");
      }
      
      // Determine landlord name, phone, email based on billing same as shipping
      let landlordName, landlordPhone, landlordEmail;
      if (isBillingSameAsShipping) {
        // Use shipping contact details for landlord
        landlordName = document.getElementById("shippingContactName")?.value?.trim() || "New Account";
        landlordPhone = stripPhoneFormatting(document.getElementById("shippingContactPhone")?.value) || "";
        landlordEmail = document.getElementById("shippingContactEmail")?.value?.trim() || "";
      } else {
        landlordName = newLandlordNameVal;
        landlordPhone = newLandlordPhoneVal;
        landlordEmail = newLandlordEmailVal;
      }

      return {
        scenario,

        account: {
          landlordAccountId: landlordAccountId,
          createLandlord: createNewLandlord,
          landlordAddress: landlordAddress,
          updateBillingAddress: landlordAccountId && !createNewLandlord, // Update address on existing account
          newLandlordName: createNewLandlord ? landlordName : null,
          newLandlordPhone: createNewLandlord ? landlordPhone : null,
          newLandlordEmail: createNewLandlord ? landlordEmail : null,
          // Account type based on billing belongs to (parent position)
          type: getAccountTypeForBelongsTo(isBillingSameAsShipping 
            ? document.getElementById("shippingBelongsTo")?.value 
            : belongsValue)
        },

        contact: {
          // Use shipping contact if selected from address dropdown, otherwise use billing contact
          existingId: shippingSelectedContact?.id || selectedContact?.id || null,
          name: document.getElementById("shippingContactName")?.value?.trim() || contactName.value.trim(),
          email: document.getElementById("shippingContactEmail")?.value?.trim() || contactEmail.value.trim(),
          phone: stripPhoneFormatting(document.getElementById("shippingContactPhone")?.value || contactPhone.value),
          // Tenant scenario: child contact roles based on shipping belongs to
          roles: getRolesForBelongsTo(document.getElementById("shippingBelongsTo")?.value || "TENANT", false),
          doNotInvoice: true
        },

        serviceLocation: {
          existingId: existingServiceLocationId,
          isNew: !existingServiceLocationId,
          addressType: addressType?.value || "",
          roomLocation: shipRoomLocation.value.trim(),
          street: shipStreet.value.trim(),
          city: shipCity.value.trim(),
          province: shipProvince.value.trim(),
          postal: shipPostal.value.trim(),
          country: shipCountry.value.trim()
        },

        billingAddress: landlordAddress
      };
    }




  </script>

</body>

</html>